<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pipapr.viewer API documentation</title>
<meta name="description" content="Module containing classes and functions relative to Viewing …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pipapr.viewer</code></h1>
</header>
<section id="section-intro">
<p>Module containing classes and functions relative to Viewing.</p>
<p>By using this code you agree to the terms of the software license agreement.</p>
<p>© Copyright 2020 Wyss Center for Bio and Neuro Engineering – All rights reserved</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module containing classes and functions relative to Viewing.

By using this code you agree to the terms of the software license agreement.

© Copyright 2020 Wyss Center for Bio and Neuro Engineering – All rights reserved
&#34;&#34;&#34;

from glob import glob
import os
import pandas as pd
from skimage.io import imread
from skimage.transform import resize
from skimage.exposure import rescale_intensity
from skimage.color import hsv2rgb
import numpy as np
import pyapr
import napari
from napari.layers import Image, Labels, Points
import pipapr
from matplotlib.colors import LogNorm
import matplotlib.pyplot as plt


def display_apr_from_path(path, **kwargs):
    &#34;&#34;&#34;
    Display an APR using Napari from a filepath.
    Parameters
    ----------
    path

    Returns
    -------

    &#34;&#34;&#34;
    apr = pyapr.APR()
    parts = pyapr.ShortParticles()
    pyapr.io.read(path, apr, parts)
    layer = apr_to_napari_Image(apr, parts)
    display_layers_pyramidal([layer], level_delta=0, **kwargs)

def display_apr(apr, parts, **kwargs):
    &#34;&#34;&#34;
    Display an APR using Napari from previously loaded data.

    Parameters
    ----------
    apr : pyapr.APR
        Input APR data structure
    parts : pyapr.FloatParticles or pyapr.ShortParticles
        Input particle intensities

    Returns
    -------
    None
    &#34;&#34;&#34;

    l = apr_to_napari_Image(apr, parts, **kwargs)
    display_layers_pyramidal([l], level_delta=0)


def apr_to_napari_Image(apr: pyapr.APR,
                        parts: (pyapr.ShortParticles, pyapr.FloatParticles),
                        mode: str = &#39;constant&#39;,
                        level_delta: int = 0,
                        **kwargs):
    &#34;&#34;&#34;
    Construct a napari &#39;Image&#39; layer from an APR. Pixel values are reconstructed on the fly via the APRSlicer class.

    Parameters
    ----------
    apr : pyapr.APR
        Input APR data structure
    parts : pyapr.FloatParticles or pyapr.ShortParticles
        Input particle intensities
    mode: str
        Interpolation mode to reconstruct pixel values. Supported values are
            constant:   piecewise constant interpolation
            smooth:     smooth interpolation (via level-adaptive separable smoothing). Note: significantly slower than constant.
            level:      interpolate the particle levels to the pixels
        (default: constant)
    level_delta: int
        Sets the resolution of the reconstruction. The size of the image domain is multiplied by a factor of 2**level_delta.
        Thus, a value of 0 corresponds to the original pixel image resolution, -1 halves the resolution and +1 doubles it.
        (default: 0)

    Returns
    -------
    out : napari.layers.Image
        An Image layer of the APR that can be viewed in napari.
    &#34;&#34;&#34;
    if &#39;contrast_limits&#39; in kwargs:
        contrast_limits = kwargs.get(&#39;contrast_limits&#39;)
        del kwargs[&#39;contrast_limits&#39;]
    else:
        cmin = apr.level_min() if mode == &#39;level&#39; else parts.min()
        cmax = apr.level_max() if mode == &#39;level&#39; else parts.max()
        contrast_limits = [cmin, cmax]
    if &#39;tree_mode&#39; in kwargs:
        tree_mode = kwargs.get(&#39;tree_mode&#39;)
        del kwargs[&#39;tree_mode&#39;]
    else:
        tree_mode = &#39;mean&#39;
    par = apr.get_parameters()
    return Image(data=pyapr.data_containers.APRSlicer(apr, parts, mode=mode, level_delta=level_delta, tree_mode=tree_mode),
                 rgb=False, multiscale=False, contrast_limits=contrast_limits,
                 scale=[par.dz, par.dx, par.dy], **kwargs)


def apr_to_napari_Labels(apr: pyapr.APR,
                        parts: pyapr.ShortParticles,
                        mode: str = &#39;constant&#39;,
                        level_delta: int = 0,
                        **kwargs):
    &#34;&#34;&#34;
    Construct a napari &#39;Layers&#39; layer from an APR. Pixel values are reconstructed on the fly via the APRSlicer class.

    Parameters
    ----------
    apr : pyapr.APR
        Input APR data structure
    parts : pyapr.FloatParticles or pyapr.ShortParticles
        Input particle intensities
    mode: str
        Interpolation mode to reconstruct pixel values. Supported values are
            constant:   piecewise constant interpolation
            smooth:     smooth interpolation (via level-adaptive separable smoothing). Note: significantly slower than constant.
            level:      interpolate the particle levels to the pixels
        (default: constant)
    level_delta: int
        Sets the resolution of the reconstruction. The size of the image domain is multiplied by a factor of 2**level_delta.
        Thus, a value of 0 corresponds to the original pixel image resolution, -1 halves the resolution and +1 doubles it.
        (default: 0)

    Returns
    -------
    out : napari.layers.Image
        A Labels layer of the APR that can be viewed in napari.
    &#34;&#34;&#34;
    if &#39;contrast_limits&#39; in kwargs:
        del kwargs[&#39;contrast_limits&#39;]
    par = apr.get_parameters()
    return Labels(data=pyapr.data_containers.APRSlicer(apr, parts, mode=mode, level_delta=level_delta, tree_mode=&#39;max&#39;),
                  multiscale=False, scale=[par.dz, par.dx, par.dy], **kwargs)

# Define a callback that will take the value of the slider and the viewer
def resolution_callback(viewer, value):
    for l in viewer.layers:
        if isinstance(l.data, pyapr.APRSlicer):
            old_value = -l.data.patch.level_delta
            l.data.set_level_delta(-value)
            l.translate = l.translate/2**(value-old_value)
    viewer.dims.set_point(axis=0, value=viewer.dims.point[0] / 2 ** (value-old_value))
    viewer.status = str(value)
    viewer._update_layers()
    viewer.reset_view()


def display_layers(layers):
    &#34;&#34;&#34;
    Display a list of layers using Napari.

    Parameters
    ----------
    layers: (list) list of layers to display

    Returns
    -------
    napari viewer.
    &#34;&#34;&#34;

    viewer = napari.Viewer()
    for layer in layers:
        viewer.add_layer(layer)

    napari.run()


    return viewer


def display_layers_pyramidal(layers, level_delta):
    &#34;&#34;&#34;
    Display a list of layers using Napari.

    Parameters
    ----------
    layers: (list) list of layers to display

    Returns
    -------
    napari viewer.
    &#34;&#34;&#34;

    viewer = napari.Viewer()
    for layer in layers:
        viewer.add_layer(layer)

    from qtpy.QtCore import Qt
    from qtpy.QtWidgets import QSlider


    my_slider = QSlider(Qt.Horizontal)
    my_slider.setMinimum(0)
    layers_apr = [l for l in layers if isinstance(l.data, pyapr.data_containers.APRSlicer)]
    l_max = np.min([l.data.apr.level_max() for l in layers_apr])
    l_min = 5 if l_max &gt; 5 else 1
    my_slider.setMaximum(l_max-l_min)
    my_slider.setSingleStep(1)
    my_slider.setValue(-level_delta)

    # Connect your slider to your callback function
    my_slider.valueChanged[int].connect(
        lambda value=my_slider: resolution_callback(viewer, value)
    )
    viewer.window.add_dock_widget(my_slider, name=&#39;Downsampling&#39;, area=&#39;left&#39;)

    napari.run()


    return viewer


def display_segmentation(apr, parts, mask, pyramidal=True, **kwargs):
    &#34;&#34;&#34;
    This function displays an image and its associated segmentation map. It uses napari to lazily generate the pixel
    data from APR on the fly.

    Parameters
    ----------
    apr: (APR) apr object
    parts: (ParticleData) particle object representing the image
    mask: (ParticleData) particle object representing the segmentation mask/connected component

    Returns
    -------
    None
    &#34;&#34;&#34;
    layers = []
    layers.append(apr_to_napari_Image(apr, parts, name=&#39;APR&#39;, **kwargs))
    layers.append(apr_to_napari_Labels(apr, mask, name=&#39;Segmentation&#39;, opacity=0.3, **kwargs))
    if pyramidal:
        display_layers_pyramidal(layers, level_delta=0)
    else:
        display_layers(layers)


def display_heatmap(heatmap, atlas=None, data=None, log=False):
    &#34;&#34;&#34;
    Display a heatmap (e.g. cell density) that can be overlaid on intensity data and atlas.
    Parameters
    ----------
    heatmap: (np.array) array containing the heatmap to be displayed
    atlas: (np.array) array containing the atlas which will be automatically scaled to the heatmap
    data: (np.array) array containing the data.
    log: (bool) plot in logscale (only used for 2D).

    Returns
    -------
    None
    &#34;&#34;&#34;

    # If u is 2D then use matplotlib so we have a scale bar
    if heatmap.ndim == 2:
        fig, ax = plt.subplots()
        if log:
            h = ax.imshow(heatmap, norm=LogNorm(), cmap=&#39;jet&#39;)
        else:
            h = ax.imshow(heatmap, cmap=&#39;jet&#39;)
        cbar = fig.colorbar(h, ax=ax)
        cbar.set_label(&#39;Number of detected cells&#39;)
        ax.set_xticks([])
        ax.set_yticks([])
    # If u is 3D then use napari but no colorbar for now
    elif heatmap.ndim == 3:
        with napari.gui_qt():
            viewer = napari.Viewer()
            viewer.add_image(heatmap, colormap=&#39;inferno&#39;, name=&#39;Heatmap&#39;, blending=&#39;additive&#39;, opacity=0.7)
            if atlas is not None:
                viewer.add_labels(atlas, name=&#39;Atlas regions&#39;, opacity=0.7)
            if data is not None:
                viewer.add_image(data, name=&#39;Intensity data&#39;, blending=&#39;additive&#39;,
                                 scale=np.array(heatmap.shape)/np.array(data.shape), opacity=0.7)


def compare_stitching(stitcher1, stitcher2, loc=None, n_proj=0, dim=0, downsample=2, color=False, rel_map=False):
    &#34;&#34;&#34;
    Compare two stitching at a given depth z.

    Parameters
    ----------
    stitcher1: (tileStitcher) stitcher object 1
    stitcher2: (tileStitcher) stitcher object 2
    loc: (int) position in the given dimension
    n_proj: (int) number of plane to perform the max-projection
    downsample: (int) downsampling factor for the reconstruction
    color: (bool) option to display in color
    rel_map: (bool) overlay reliability map on the reconstructed data

    Returns
    -------
    None
    &#34;&#34;&#34;


    u1 = stitcher1.reconstruct_slice(loc=loc, n_proj=n_proj, dim=dim, downsample=downsample, color=color, plot=False)
    u2 = stitcher2.reconstruct_slice(loc=loc, n_proj=n_proj, dim=dim, downsample=downsample, color=color, plot=False)

    if color:
        fig, ax = plt.subplots(1, 2, sharex=True, sharey=True)
        data_to_display = np.ones_like(u1, dtype=&#39;uint8&#39;)
        for i in range(2):
            tmp = np.log(u1[:, :, i] + 200)
            vmin, vmax = np.percentile(tmp[tmp &gt; np.log(1 + 200)], (1, 99.9))
            data_to_display[:, :, i] = rescale_intensity(tmp, in_range=(vmin, vmax), out_range=&#39;uint8&#39;)
        ax[0].imshow(data_to_display)
        data_to_display = np.ones_like(u2, dtype=&#39;uint8&#39;)
        for i in range(2):
            tmp = np.log(u2[:, :, i] + 200)
            vmin, vmax = np.percentile(tmp[tmp &gt; np.log(1 + 200)], (1, 99.9))
            data_to_display[:, :, i] = rescale_intensity(tmp, in_range=(vmin, vmax), out_range=&#39;uint8&#39;)
        ax[1].imshow(data_to_display)
    else:
        fig, ax = plt.subplots(1, 2, sharex=True, sharey=True)
        ax[0].imshow(np.log(u1), cmap=&#39;gray&#39;)
        if rel_map:
            try:
                rel_map = resize(np.mean(stitcher1.plot_stitching_info(), axis=0), u1.shape, order=1)
                ax[0].imshow(rel_map, cmap=&#39;turbo&#39;, alpha=0.5)
            except:
                pass
        ax[1].imshow(np.log(u2), cmap=&#39;gray&#39;)
        if rel_map:
            try:
                rel_map = resize(np.mean(stitcher2.plot_stitching_info(), axis=0), u1.shape, order=1)
                ax[1].imshow(rel_map, cmap=&#39;turbo&#39;, alpha=0.5)
            except:
                pass


def reconstruct_colored_projection(apr, parts, loc=None, dim=0, n_proj=0, downsample=1, threshold=None, plot=True):
    &#34;&#34;&#34;
    Reconstruct colored depth projection.

    &#34;&#34;&#34;

    level_delta = int(-np.sign(downsample) * np.log2(np.abs(downsample)))

    if loc is None:
        apr_shape = apr.shape()
        loc = int(apr_shape[dim] / 2)

    if loc &gt; apr_shape[dim]:
        raise ValueError(&#39;Error: loc is too large ({}), maximum loc at this downsample is {}.&#39;.format(loc, apr_shape[dim]))

    locf = min(loc+n_proj, apr_shape[dim])
    patch = pyapr.ReconPatch()
    if dim==0:
        patch.z_begin = loc
        patch.z_end = locf
    if dim==1:
        patch.y_begin = loc
        patch.y_end = locf
    if dim==2:
        patch.x_begin = loc
        patch.x_end = locf

    data = pyapr.numerics.reconstruction.reconstruct_constant(apr, parts, patch=patch)

    V = data.max(axis=dim)
    S = np.ones_like(V) * 0.7
    if threshold is not None:
        S[V&lt;threshold] = 0
    H = np.argmax(data, axis=dim)
    H = rescale_intensity(gaussian(H, sigma=5), out_range=np.float64)*0.66
    V = np.log(V + 200)
    vmin, vmax = np.percentile(V[V &gt; np.log(100)], (1, 99.9))
    V = rescale_intensity(V, in_range=(vmin, vmax), out_range=np.float64)
    S = S * V
    rgb = hsv2rgb(np.dstack((H,S,V)))
    rescale_intensity(rgb, out_range=&#39;uint8&#39;)

    if plot:
        plt.figure()
        plt.imshow(rgb)

    return rgb

class tileViewer():
    &#34;&#34;&#34;
    Class to display the registration and segmentation using Napari.
    &#34;&#34;&#34;
    def __init__(self,
                 tiles,
                 database,
                 segmentation: bool=False,
                 cells=None,
                 atlaser=None):
        &#34;&#34;&#34;

        Parameters
        ----------
        tiles: (tileParser) tileParser object containing the dataset to be displayed.
        database: database containing the tile positions.
        segmentation: (bool) option to also display the segmentation (connected component) data.
        cells: (np.array) cells center to be displayed.
        atlaser: (tileAtlaser) tileAtlaser object containing the Atlas to be displayed.
        &#34;&#34;&#34;

        self.tiles = tiles

        if isinstance(database, pipapr.stitcher.tileStitcher):
            self.database = database.database
        elif isinstance(database, pd.DataFrame):
            self.database = database
        elif isinstance(database, str):
            self.database = pd.read_csv(database)
        else:
            raise TypeError(&#39;Error: unknown type for database.&#39;)

        self.nrow = tiles.nrow
        self.ncol = tiles.ncol
        self.loaded_ind = []
        self.loaded_tiles = {}
        self.segmentation = segmentation
        self.loaded_segmentation = {}
        self.cells = cells
        self.atlaser = atlaser

    def get_layers_all_tiles(self, downsample=1, **kwargs):
        &#34;&#34;&#34;
        Display all parsed tiles.

        Parameters
        ----------
        downsample: (int) downsampling parameter for APRSlicer
                            (1: full resolution, 2: 2x downsampling, 4: 4x downsampling..etc)
        kwargs: (dict) dictionary passed to Napari for custom option

        Returns
        -------
        None
        &#34;&#34;&#34;

        # Compute layers to be displayed by Napari
        layers = []

        # Convert downsample to level delta
        level_delta = int(-np.sign(downsample)*np.log2(np.abs(downsample)))

        for tile in self.tiles:
            # Load tile if not loaded, else use cached tile
            ind = np.ravel_multi_index((tile.row, tile.col), dims=(self.nrow, self.ncol))
            if self._is_tile_loaded(tile.row, tile.col):
                apr, parts = self.loaded_tiles[ind]
                if self.segmentation:
                    cc = self.loaded_segmentation[ind]
            else:
                tile.load_tile()
                apr, parts = tile.apr, tile.parts
                self.loaded_ind.append(ind)
                self.loaded_tiles[ind] = apr, parts
                if self.segmentation:
                    tile.load_segmentation()
                    cc = tile.parts_cc
                    self.loaded_segmentation[ind] = cc


            position = self._get_tile_position(tile.row, tile.col)
            if level_delta != 0:
                position = [x/downsample for x in position]
            layers.append(apr_to_napari_Image(apr, parts,
                                              mode=&#39;constant&#39;,
                                              name=&#39;Tile [{}, {}]&#39;.format(tile.row, tile.col),
                                              translate=position,
                                              opacity=0.7,
                                              level_delta=level_delta,
                                              **kwargs))
            if self.segmentation:
                layers.append(apr_to_napari_Labels(apr, cc,
                                                   mode=&#39;constant&#39;,
                                                   name=&#39;Segmentation [{}, {}]&#39;.format(tile.row, tile.col),
                                                   translate=position,
                                                   level_delta=level_delta,
                                                   opacity=0.7))
        if self.cells is not None:
            par = apr.get_parameters()
            layers.append(Points(self.cells, opacity=0.7, name=&#39;Cells center&#39;,
                                 scale=[par.dz/downsample, par.dx/downsample, par.dy/downsample]))

        if self.atlaser is not None:
            layers.append(Labels(self.atlaser.atlas, opacity=0.7, name=&#39;Atlas&#39;,
                                 scale=[self.atlaser.z_downsample/downsample,
                                        self.atlaser.y_downsample/downsample,
                                        self.atlaser.x_downsample/downsample]))

        return layers

    def display_all_tiles(self, pyramidal=True, downsample=1, color=False, **kwargs):
        &#34;&#34;&#34;
        Display all parsed tiles.

        Parameters
        ----------
        downsample: (int) downsampling parameter for APRSlicer
                            (1: full resolution, 2: 2x downsampling, 4: 4x downsampling..etc)
        kwargs: (dict) dictionary passed to Napari for custom option

        Returns
        -------
        None
        &#34;&#34;&#34;

        # Compute layers to be displayed by Napari
        layers = []

        # Convert downsample to level delta
        level_delta = int(-np.sign(downsample)*np.log2(np.abs(downsample)))

        for tile in self.tiles:
            # Load tile if not loaded, else use cached tile
            ind = np.ravel_multi_index((tile.row, tile.col), dims=(self.nrow, self.ncol))
            if self._is_tile_loaded(tile.row, tile.col):
                apr, parts = self.loaded_tiles[ind]
                if self.segmentation:
                    cc = self.loaded_segmentation[ind]
            else:
                tile.load_tile()
                apr, parts = tile.apr, tile.parts
                self.loaded_ind.append(ind)
                self.loaded_tiles[ind] = apr, parts
                if self.segmentation:
                    tile.load_segmentation()
                    cc = tile.parts_cc
                    self.loaded_segmentation[ind] = cc

            position = self._get_tile_position(tile.row, tile.col)

            if color:
                blending = &#39;additive&#39;
                if tile.col % 2:
                    if tile.row % 2:
                        cmap = &#39;red&#39;
                    else:
                        cmap = &#39;green&#39;
                else:
                    if tile.row % 2:
                        cmap = &#39;green&#39;
                    else:
                        cmap = &#39;red&#39;
            else:
                cmap = &#39;gray&#39;
                blending = &#39;translucent&#39;

            if level_delta != 0:
                position = [x/downsample for x in position]
            layers.append(apr_to_napari_Image(apr, parts,
                                              mode=&#39;constant&#39;,
                                              name=&#39;Tile [{}, {}]&#39;.format(tile.row, tile.col),
                                              translate=position,
                                              opacity=0.7,
                                              level_delta=level_delta,
                                              **kwargs))
            if self.segmentation:
                layers.append(apr_to_napari_Labels(apr, cc,
                                                   mode=&#39;constant&#39;,
                                                   name=&#39;Segmentation [{}, {}]&#39;.format(tile.row, tile.col),
                                                   translate=position,
                                                   level_delta=level_delta,
                                                   colormap=cmap,
                                                   blending=blending,
                                                   opacity=0.7))
        if self.cells is not None:
            par = apr.get_parameters()
            layers.append(Points(self.cells, opacity=0.7, name=&#39;Cells center&#39;,
                                 scale=[par.dz/downsample, par.dx/downsample, par.dy/downsample]))

        if self.atlaser is not None:
            layers.append(Labels(self.atlaser.atlas, opacity=0.7, name=&#39;Atlas&#39;,
                                 scale=[self.atlaser.z_downsample/downsample,
                                        self.atlaser.y_downsample/downsample,
                                        self.atlaser.x_downsample/downsample]))

        # Display layers
        if pyramidal:
            display_layers_pyramidal(layers, level_delta)
        else:
            display_layers(layers)

    def display_tiles(self, coords, pyramidal=True, downsample=1, color=False, **kwargs):
        &#34;&#34;&#34;
        Display tiles at position coords.

        Parameters
        ----------
        coords: (list) list of tuples (row, col) containing the tile coordinate to display.
        downsample: (int) downsampling parameter for APRSlicer
                            (1: full resolution, 2: 2x downsampling, 4: 4x downsampling..etc)
        kwargs: (dict) dictionary passed to Napari for custom option
        color: (bool) option to display in color

        Returns
        -------
        None
        &#34;&#34;&#34;

        # Compute layers to be displayed by Napari
        layers = []

        # Convert downsample to level delta
        level_delta = int(-np.sign(downsample) * np.log2(np.abs(downsample)))

        for tile in self.tiles:
            if (tile.row, tile.col) in coords:
                # Load tile if not loaded, else use cached tile
                ind = np.ravel_multi_index((tile.row, tile.col), dims=(self.nrow, self.ncol))
                if self._is_tile_loaded(tile.row, tile.col):
                    apr, parts = self.loaded_tiles[ind]
                    if self.segmentation:
                        cc = self.loaded_segmentation[ind]
                else:
                    tile.load_tile()
                    apr, parts = tile.apr, tile.parts
                    self.loaded_ind.append(ind)
                    self.loaded_tiles[ind] = apr, parts
                    if self.segmentation:
                        tile.load_segmentation()
                        cc = tile.parts_cc
                        self.loaded_segmentation[ind] = cc

                position = self._get_tile_position(tile.row, tile.col)
                if level_delta != 0:
                    position = [x / downsample for x in position]

                if color:
                    blending = &#39;additive&#39;
                    if tile.col % 2:
                        if tile.row % 2:
                            cmap = &#39;red&#39;
                        else:
                            cmap = &#39;green&#39;
                    else:
                        if tile.row % 2:
                            cmap = &#39;green&#39;
                        else:
                            cmap = &#39;red&#39;
                else:
                    cmap = &#39;gray&#39;
                    blending = &#39;translucent&#39;

                layers.append(apr_to_napari_Image(apr, parts,
                                                  mode=&#39;constant&#39;,
                                                  name=&#39;Tile [{}, {}]&#39;.format(tile.row, tile.col),
                                                  translate=position,
                                                  opacity=0.7,
                                                  level_delta=level_delta,
                                                  colormap=cmap,
                                                  blending=blending,
                                                  **kwargs))
                if self.segmentation:
                    layers.append(apr_to_napari_Labels(apr, cc,
                                                       mode=&#39;constant&#39;,
                                                       name=&#39;Segmentation [{}, {}]&#39;.format(tile.row, tile.col),
                                                       translate=position,
                                                       level_delta=level_delta,
                                                       opacity=0.7))
        if self.cells is not None:
            par = apr.get_parameters()
            layers.append(Points(self.cells, opacity=0.7, name=&#39;Cells center&#39;,
                                 scale=[par.dz / downsample, par.dx / downsample, par.dy / downsample]))

        if self.atlaser is not None:
            layers.append(Labels(self.atlaser.atlas, opacity=0.7, name=&#39;Atlas&#39;,
                                 scale=[self.atlaser.z_downsample / downsample,
                                        self.atlaser.y_downsample / downsample,
                                        self.atlaser.x_downsample / downsample]))

        # Display layers
        if pyramidal:
            display_layers_pyramidal(layers, level_delta)
        else:
            display_layers(layers)

    def check_stitching(self, downsample=8, color=False, **kwargs):

        # Compute layers to be displayed by Napari
        layers = []

        # Convert downsample to level delta
        level_delta = int(-np.sign(downsample)*np.log2(np.abs(downsample)))

        for tile in self.tiles:
            tile.lazy_load_tile(level_delta=level_delta)
            position = self._get_tile_position(tile.row, tile.col)

            if level_delta != 0:
                position = [x/downsample for x in position]

            if color:
                blending = &#39;additive&#39;
                if tile.col % 2:
                    if tile.row % 2:
                        cmap = &#39;red&#39;
                    else:
                        cmap = &#39;green&#39;
                else:
                    if tile.row % 2:
                        cmap = &#39;green&#39;
                    else:
                        cmap = &#39;red&#39;
            else:
                cmap = &#39;gray&#39;
                blending = &#39;translucent&#39;

            layers.append(Image(tile.lazy_data,
                              name=&#39;Tile [{}, {}]&#39;.format(tile.row, tile.col),
                              translate=position,
                              opacity=0.7,
                              colormap=cmap,
                              blending=blending,
                              **kwargs))

        display_layers(layers)


    def _is_tile_loaded(self, row, col):
        &#34;&#34;&#34;
        Returns True is tile is loaded, False otherwise.
        &#34;&#34;&#34;
        ind = np.ravel_multi_index((row, col), dims=(self.nrow, self.ncol))
        return ind in self.loaded_ind

    def _load_tile(self, row, col):
        &#34;&#34;&#34;
        Load the tile at position [row, col].
        &#34;&#34;&#34;
        df = self.database
        path = df[(df[&#39;row&#39;] == row) &amp; (df[&#39;col&#39;] == col)][&#39;path&#39;].values[0]
        if self.tiles.type == &#39;tiff2D&#39;:
            files = glob(os.path.join(path, &#39;*.tif&#39;))
            im = imread(files[0])
            u = np.zeros((len(files), *im.shape))
            u[0] = im
            files.pop(0)
            for i, file in enumerate(files):
                u[i+1] = imread(file)
            return self._get_apr(u)
        elif self.tiles.type == &#39;tiff3D&#39;:
            u = imread(path)
            return self._get_apr(u)
        elif self.tiles.type == &#39;apr&#39;:
            apr = pyapr.APR()
            parts = pyapr.ShortParticles()
            pyapr.io.read(path, apr, parts)
            u = (apr, parts)
            return u
        else:
            raise TypeError(&#39;Error: image type {} not supported.&#39;.format(self.type))

    def _get_tile_position(self, row, col):
        &#34;&#34;&#34;
        Parse tile position in the database.
        &#34;&#34;&#34;
        df = self.database
        tile_df = df[(df[&#39;row&#39;] == row) &amp; (df[&#39;col&#39;] == col)]
        px = tile_df[&#39;ABS_H&#39;].values[0]
        py = tile_df[&#39;ABS_V&#39;].values[0]
        pz = tile_df[&#39;ABS_D&#39;].values[0]

        return [pz, py, px]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pipapr.viewer.apr_to_napari_Image"><code class="name flex">
<span>def <span class="ident">apr_to_napari_Image</span></span>(<span>apr: _pyaprwrapper.data_containers.APR, parts: (<class '_pyaprwrapper.data_containers.ShortParticles'>, <class '_pyaprwrapper.data_containers.FloatParticles'>), mode: str = 'constant', level_delta: int = 0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a napari 'Image' layer from an APR. Pixel values are reconstructed on the fly via the APRSlicer class.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>apr</code></strong> :&ensp;<code>pyapr.APR</code></dt>
<dd>Input APR data structure</dd>
<dt><strong><code>parts</code></strong> :&ensp;<code>pyapr.FloatParticles</code> or <code>pyapr.ShortParticles</code></dt>
<dd>Input particle intensities</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>Interpolation mode to reconstruct pixel values. Supported values are
constant:
piecewise constant interpolation
smooth:
smooth interpolation (via level-adaptive separable smoothing). Note: significantly slower than constant.
level:
interpolate the particle levels to the pixels
(default: constant)</dd>
<dt><strong><code>level_delta</code></strong> :&ensp;<code>int</code></dt>
<dd>Sets the resolution of the reconstruction. The size of the image domain is multiplied by a factor of 2**level_delta.
Thus, a value of 0 corresponds to the original pixel image resolution, -1 halves the resolution and +1 doubles it.
(default: 0)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>napari.layers.Image</code></dt>
<dd>An Image layer of the APR that can be viewed in napari.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apr_to_napari_Image(apr: pyapr.APR,
                        parts: (pyapr.ShortParticles, pyapr.FloatParticles),
                        mode: str = &#39;constant&#39;,
                        level_delta: int = 0,
                        **kwargs):
    &#34;&#34;&#34;
    Construct a napari &#39;Image&#39; layer from an APR. Pixel values are reconstructed on the fly via the APRSlicer class.

    Parameters
    ----------
    apr : pyapr.APR
        Input APR data structure
    parts : pyapr.FloatParticles or pyapr.ShortParticles
        Input particle intensities
    mode: str
        Interpolation mode to reconstruct pixel values. Supported values are
            constant:   piecewise constant interpolation
            smooth:     smooth interpolation (via level-adaptive separable smoothing). Note: significantly slower than constant.
            level:      interpolate the particle levels to the pixels
        (default: constant)
    level_delta: int
        Sets the resolution of the reconstruction. The size of the image domain is multiplied by a factor of 2**level_delta.
        Thus, a value of 0 corresponds to the original pixel image resolution, -1 halves the resolution and +1 doubles it.
        (default: 0)

    Returns
    -------
    out : napari.layers.Image
        An Image layer of the APR that can be viewed in napari.
    &#34;&#34;&#34;
    if &#39;contrast_limits&#39; in kwargs:
        contrast_limits = kwargs.get(&#39;contrast_limits&#39;)
        del kwargs[&#39;contrast_limits&#39;]
    else:
        cmin = apr.level_min() if mode == &#39;level&#39; else parts.min()
        cmax = apr.level_max() if mode == &#39;level&#39; else parts.max()
        contrast_limits = [cmin, cmax]
    if &#39;tree_mode&#39; in kwargs:
        tree_mode = kwargs.get(&#39;tree_mode&#39;)
        del kwargs[&#39;tree_mode&#39;]
    else:
        tree_mode = &#39;mean&#39;
    par = apr.get_parameters()
    return Image(data=pyapr.data_containers.APRSlicer(apr, parts, mode=mode, level_delta=level_delta, tree_mode=tree_mode),
                 rgb=False, multiscale=False, contrast_limits=contrast_limits,
                 scale=[par.dz, par.dx, par.dy], **kwargs)</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.apr_to_napari_Labels"><code class="name flex">
<span>def <span class="ident">apr_to_napari_Labels</span></span>(<span>apr: _pyaprwrapper.data_containers.APR, parts: _pyaprwrapper.data_containers.ShortParticles, mode: str = 'constant', level_delta: int = 0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a napari 'Layers' layer from an APR. Pixel values are reconstructed on the fly via the APRSlicer class.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>apr</code></strong> :&ensp;<code>pyapr.APR</code></dt>
<dd>Input APR data structure</dd>
<dt><strong><code>parts</code></strong> :&ensp;<code>pyapr.FloatParticles</code> or <code>pyapr.ShortParticles</code></dt>
<dd>Input particle intensities</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>Interpolation mode to reconstruct pixel values. Supported values are
constant:
piecewise constant interpolation
smooth:
smooth interpolation (via level-adaptive separable smoothing). Note: significantly slower than constant.
level:
interpolate the particle levels to the pixels
(default: constant)</dd>
<dt><strong><code>level_delta</code></strong> :&ensp;<code>int</code></dt>
<dd>Sets the resolution of the reconstruction. The size of the image domain is multiplied by a factor of 2**level_delta.
Thus, a value of 0 corresponds to the original pixel image resolution, -1 halves the resolution and +1 doubles it.
(default: 0)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code>napari.layers.Image</code></dt>
<dd>A Labels layer of the APR that can be viewed in napari.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apr_to_napari_Labels(apr: pyapr.APR,
                        parts: pyapr.ShortParticles,
                        mode: str = &#39;constant&#39;,
                        level_delta: int = 0,
                        **kwargs):
    &#34;&#34;&#34;
    Construct a napari &#39;Layers&#39; layer from an APR. Pixel values are reconstructed on the fly via the APRSlicer class.

    Parameters
    ----------
    apr : pyapr.APR
        Input APR data structure
    parts : pyapr.FloatParticles or pyapr.ShortParticles
        Input particle intensities
    mode: str
        Interpolation mode to reconstruct pixel values. Supported values are
            constant:   piecewise constant interpolation
            smooth:     smooth interpolation (via level-adaptive separable smoothing). Note: significantly slower than constant.
            level:      interpolate the particle levels to the pixels
        (default: constant)
    level_delta: int
        Sets the resolution of the reconstruction. The size of the image domain is multiplied by a factor of 2**level_delta.
        Thus, a value of 0 corresponds to the original pixel image resolution, -1 halves the resolution and +1 doubles it.
        (default: 0)

    Returns
    -------
    out : napari.layers.Image
        A Labels layer of the APR that can be viewed in napari.
    &#34;&#34;&#34;
    if &#39;contrast_limits&#39; in kwargs:
        del kwargs[&#39;contrast_limits&#39;]
    par = apr.get_parameters()
    return Labels(data=pyapr.data_containers.APRSlicer(apr, parts, mode=mode, level_delta=level_delta, tree_mode=&#39;max&#39;),
                  multiscale=False, scale=[par.dz, par.dx, par.dy], **kwargs)</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.compare_stitching"><code class="name flex">
<span>def <span class="ident">compare_stitching</span></span>(<span>stitcher1, stitcher2, loc=None, n_proj=0, dim=0, downsample=2, color=False, rel_map=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare two stitching at a given depth z.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stitcher1</code></strong> :&ensp;<code>(tileStitcher) stitcher object 1</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>stitcher2</code></strong> :&ensp;<code>(tileStitcher) stitcher object 2</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>(int) position in the given dimension</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>n_proj</code></strong> :&ensp;<code>(int) number</code> of <code>plane to perform the max-projection</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>downsample</code></strong> :&ensp;<code>(int) downsampling factor for the reconstruction</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>(bool) option to display in color</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>rel_map</code></strong> :&ensp;<code>(bool) overlay reliability map on the reconstructed data</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_stitching(stitcher1, stitcher2, loc=None, n_proj=0, dim=0, downsample=2, color=False, rel_map=False):
    &#34;&#34;&#34;
    Compare two stitching at a given depth z.

    Parameters
    ----------
    stitcher1: (tileStitcher) stitcher object 1
    stitcher2: (tileStitcher) stitcher object 2
    loc: (int) position in the given dimension
    n_proj: (int) number of plane to perform the max-projection
    downsample: (int) downsampling factor for the reconstruction
    color: (bool) option to display in color
    rel_map: (bool) overlay reliability map on the reconstructed data

    Returns
    -------
    None
    &#34;&#34;&#34;


    u1 = stitcher1.reconstruct_slice(loc=loc, n_proj=n_proj, dim=dim, downsample=downsample, color=color, plot=False)
    u2 = stitcher2.reconstruct_slice(loc=loc, n_proj=n_proj, dim=dim, downsample=downsample, color=color, plot=False)

    if color:
        fig, ax = plt.subplots(1, 2, sharex=True, sharey=True)
        data_to_display = np.ones_like(u1, dtype=&#39;uint8&#39;)
        for i in range(2):
            tmp = np.log(u1[:, :, i] + 200)
            vmin, vmax = np.percentile(tmp[tmp &gt; np.log(1 + 200)], (1, 99.9))
            data_to_display[:, :, i] = rescale_intensity(tmp, in_range=(vmin, vmax), out_range=&#39;uint8&#39;)
        ax[0].imshow(data_to_display)
        data_to_display = np.ones_like(u2, dtype=&#39;uint8&#39;)
        for i in range(2):
            tmp = np.log(u2[:, :, i] + 200)
            vmin, vmax = np.percentile(tmp[tmp &gt; np.log(1 + 200)], (1, 99.9))
            data_to_display[:, :, i] = rescale_intensity(tmp, in_range=(vmin, vmax), out_range=&#39;uint8&#39;)
        ax[1].imshow(data_to_display)
    else:
        fig, ax = plt.subplots(1, 2, sharex=True, sharey=True)
        ax[0].imshow(np.log(u1), cmap=&#39;gray&#39;)
        if rel_map:
            try:
                rel_map = resize(np.mean(stitcher1.plot_stitching_info(), axis=0), u1.shape, order=1)
                ax[0].imshow(rel_map, cmap=&#39;turbo&#39;, alpha=0.5)
            except:
                pass
        ax[1].imshow(np.log(u2), cmap=&#39;gray&#39;)
        if rel_map:
            try:
                rel_map = resize(np.mean(stitcher2.plot_stitching_info(), axis=0), u1.shape, order=1)
                ax[1].imshow(rel_map, cmap=&#39;turbo&#39;, alpha=0.5)
            except:
                pass</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.display_apr"><code class="name flex">
<span>def <span class="ident">display_apr</span></span>(<span>apr, parts, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Display an APR using Napari from previously loaded data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>apr</code></strong> :&ensp;<code>pyapr.APR</code></dt>
<dd>Input APR data structure</dd>
<dt><strong><code>parts</code></strong> :&ensp;<code>pyapr.FloatParticles</code> or <code>pyapr.ShortParticles</code></dt>
<dd>Input particle intensities</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_apr(apr, parts, **kwargs):
    &#34;&#34;&#34;
    Display an APR using Napari from previously loaded data.

    Parameters
    ----------
    apr : pyapr.APR
        Input APR data structure
    parts : pyapr.FloatParticles or pyapr.ShortParticles
        Input particle intensities

    Returns
    -------
    None
    &#34;&#34;&#34;

    l = apr_to_napari_Image(apr, parts, **kwargs)
    display_layers_pyramidal([l], level_delta=0)</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.display_apr_from_path"><code class="name flex">
<span>def <span class="ident">display_apr_from_path</span></span>(<span>path, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Display an APR using Napari from a filepath.
Parameters</p>
<hr>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_apr_from_path(path, **kwargs):
    &#34;&#34;&#34;
    Display an APR using Napari from a filepath.
    Parameters
    ----------
    path

    Returns
    -------

    &#34;&#34;&#34;
    apr = pyapr.APR()
    parts = pyapr.ShortParticles()
    pyapr.io.read(path, apr, parts)
    layer = apr_to_napari_Image(apr, parts)
    display_layers_pyramidal([layer], level_delta=0, **kwargs)</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.display_heatmap"><code class="name flex">
<span>def <span class="ident">display_heatmap</span></span>(<span>heatmap, atlas=None, data=None, log=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Display a heatmap (e.g. cell density) that can be overlaid on intensity data and atlas.
Parameters</p>
<hr>
<dl>
<dt><strong><code>heatmap</code></strong> :&ensp;<code>(np.array) array containing the heatmap to be displayed</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>atlas</code></strong> :&ensp;<code>(np.array) array containing the atlas which will be automatically scaled to the heatmap</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>data: (np.array) array containing the data.
log: (bool) plot in logscale (only used for 2D).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_heatmap(heatmap, atlas=None, data=None, log=False):
    &#34;&#34;&#34;
    Display a heatmap (e.g. cell density) that can be overlaid on intensity data and atlas.
    Parameters
    ----------
    heatmap: (np.array) array containing the heatmap to be displayed
    atlas: (np.array) array containing the atlas which will be automatically scaled to the heatmap
    data: (np.array) array containing the data.
    log: (bool) plot in logscale (only used for 2D).

    Returns
    -------
    None
    &#34;&#34;&#34;

    # If u is 2D then use matplotlib so we have a scale bar
    if heatmap.ndim == 2:
        fig, ax = plt.subplots()
        if log:
            h = ax.imshow(heatmap, norm=LogNorm(), cmap=&#39;jet&#39;)
        else:
            h = ax.imshow(heatmap, cmap=&#39;jet&#39;)
        cbar = fig.colorbar(h, ax=ax)
        cbar.set_label(&#39;Number of detected cells&#39;)
        ax.set_xticks([])
        ax.set_yticks([])
    # If u is 3D then use napari but no colorbar for now
    elif heatmap.ndim == 3:
        with napari.gui_qt():
            viewer = napari.Viewer()
            viewer.add_image(heatmap, colormap=&#39;inferno&#39;, name=&#39;Heatmap&#39;, blending=&#39;additive&#39;, opacity=0.7)
            if atlas is not None:
                viewer.add_labels(atlas, name=&#39;Atlas regions&#39;, opacity=0.7)
            if data is not None:
                viewer.add_image(data, name=&#39;Intensity data&#39;, blending=&#39;additive&#39;,
                                 scale=np.array(heatmap.shape)/np.array(data.shape), opacity=0.7)</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.display_layers"><code class="name flex">
<span>def <span class="ident">display_layers</span></span>(<span>layers)</span>
</code></dt>
<dd>
<div class="desc"><p>Display a list of layers using Napari.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>layers</code></strong> :&ensp;<code>(list) list</code> of <code>layers to display</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>napari viewer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_layers(layers):
    &#34;&#34;&#34;
    Display a list of layers using Napari.

    Parameters
    ----------
    layers: (list) list of layers to display

    Returns
    -------
    napari viewer.
    &#34;&#34;&#34;

    viewer = napari.Viewer()
    for layer in layers:
        viewer.add_layer(layer)

    napari.run()


    return viewer</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.display_layers_pyramidal"><code class="name flex">
<span>def <span class="ident">display_layers_pyramidal</span></span>(<span>layers, level_delta)</span>
</code></dt>
<dd>
<div class="desc"><p>Display a list of layers using Napari.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>layers</code></strong> :&ensp;<code>(list) list</code> of <code>layers to display</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>napari viewer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_layers_pyramidal(layers, level_delta):
    &#34;&#34;&#34;
    Display a list of layers using Napari.

    Parameters
    ----------
    layers: (list) list of layers to display

    Returns
    -------
    napari viewer.
    &#34;&#34;&#34;

    viewer = napari.Viewer()
    for layer in layers:
        viewer.add_layer(layer)

    from qtpy.QtCore import Qt
    from qtpy.QtWidgets import QSlider


    my_slider = QSlider(Qt.Horizontal)
    my_slider.setMinimum(0)
    layers_apr = [l for l in layers if isinstance(l.data, pyapr.data_containers.APRSlicer)]
    l_max = np.min([l.data.apr.level_max() for l in layers_apr])
    l_min = 5 if l_max &gt; 5 else 1
    my_slider.setMaximum(l_max-l_min)
    my_slider.setSingleStep(1)
    my_slider.setValue(-level_delta)

    # Connect your slider to your callback function
    my_slider.valueChanged[int].connect(
        lambda value=my_slider: resolution_callback(viewer, value)
    )
    viewer.window.add_dock_widget(my_slider, name=&#39;Downsampling&#39;, area=&#39;left&#39;)

    napari.run()


    return viewer</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.display_segmentation"><code class="name flex">
<span>def <span class="ident">display_segmentation</span></span>(<span>apr, parts, mask, pyramidal=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This function displays an image and its associated segmentation map. It uses napari to lazily generate the pixel
data from APR on the fly.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>apr</code></strong> :&ensp;<code>(APR) apr object</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>parts</code></strong> :&ensp;<code>(ParticleData) particle object representing the image</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>(ParticleData) particle object representing the segmentation mask/connected component</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_segmentation(apr, parts, mask, pyramidal=True, **kwargs):
    &#34;&#34;&#34;
    This function displays an image and its associated segmentation map. It uses napari to lazily generate the pixel
    data from APR on the fly.

    Parameters
    ----------
    apr: (APR) apr object
    parts: (ParticleData) particle object representing the image
    mask: (ParticleData) particle object representing the segmentation mask/connected component

    Returns
    -------
    None
    &#34;&#34;&#34;
    layers = []
    layers.append(apr_to_napari_Image(apr, parts, name=&#39;APR&#39;, **kwargs))
    layers.append(apr_to_napari_Labels(apr, mask, name=&#39;Segmentation&#39;, opacity=0.3, **kwargs))
    if pyramidal:
        display_layers_pyramidal(layers, level_delta=0)
    else:
        display_layers(layers)</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.reconstruct_colored_projection"><code class="name flex">
<span>def <span class="ident">reconstruct_colored_projection</span></span>(<span>apr, parts, loc=None, dim=0, n_proj=0, downsample=1, threshold=None, plot=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Reconstruct colored depth projection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstruct_colored_projection(apr, parts, loc=None, dim=0, n_proj=0, downsample=1, threshold=None, plot=True):
    &#34;&#34;&#34;
    Reconstruct colored depth projection.

    &#34;&#34;&#34;

    level_delta = int(-np.sign(downsample) * np.log2(np.abs(downsample)))

    if loc is None:
        apr_shape = apr.shape()
        loc = int(apr_shape[dim] / 2)

    if loc &gt; apr_shape[dim]:
        raise ValueError(&#39;Error: loc is too large ({}), maximum loc at this downsample is {}.&#39;.format(loc, apr_shape[dim]))

    locf = min(loc+n_proj, apr_shape[dim])
    patch = pyapr.ReconPatch()
    if dim==0:
        patch.z_begin = loc
        patch.z_end = locf
    if dim==1:
        patch.y_begin = loc
        patch.y_end = locf
    if dim==2:
        patch.x_begin = loc
        patch.x_end = locf

    data = pyapr.numerics.reconstruction.reconstruct_constant(apr, parts, patch=patch)

    V = data.max(axis=dim)
    S = np.ones_like(V) * 0.7
    if threshold is not None:
        S[V&lt;threshold] = 0
    H = np.argmax(data, axis=dim)
    H = rescale_intensity(gaussian(H, sigma=5), out_range=np.float64)*0.66
    V = np.log(V + 200)
    vmin, vmax = np.percentile(V[V &gt; np.log(100)], (1, 99.9))
    V = rescale_intensity(V, in_range=(vmin, vmax), out_range=np.float64)
    S = S * V
    rgb = hsv2rgb(np.dstack((H,S,V)))
    rescale_intensity(rgb, out_range=&#39;uint8&#39;)

    if plot:
        plt.figure()
        plt.imshow(rgb)

    return rgb</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.resolution_callback"><code class="name flex">
<span>def <span class="ident">resolution_callback</span></span>(<span>viewer, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolution_callback(viewer, value):
    for l in viewer.layers:
        if isinstance(l.data, pyapr.APRSlicer):
            old_value = -l.data.patch.level_delta
            l.data.set_level_delta(-value)
            l.translate = l.translate/2**(value-old_value)
    viewer.dims.set_point(axis=0, value=viewer.dims.point[0] / 2 ** (value-old_value))
    viewer.status = str(value)
    viewer._update_layers()
    viewer.reset_view()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pipapr.viewer.tileViewer"><code class="flex name class">
<span>class <span class="ident">tileViewer</span></span>
<span>(</span><span>tiles, database, segmentation: bool = False, cells=None, atlaser=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to display the registration and segmentation using Napari.</p>
<h2 id="parameters">Parameters</h2>
<p>tiles: (tileParser) tileParser object containing the dataset to be displayed.
database: database containing the tile positions.
segmentation: (bool) option to also display the segmentation (connected component) data.
cells: (np.array) cells center to be displayed.
atlaser: (tileAtlaser) tileAtlaser object containing the Atlas to be displayed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class tileViewer():
    &#34;&#34;&#34;
    Class to display the registration and segmentation using Napari.
    &#34;&#34;&#34;
    def __init__(self,
                 tiles,
                 database,
                 segmentation: bool=False,
                 cells=None,
                 atlaser=None):
        &#34;&#34;&#34;

        Parameters
        ----------
        tiles: (tileParser) tileParser object containing the dataset to be displayed.
        database: database containing the tile positions.
        segmentation: (bool) option to also display the segmentation (connected component) data.
        cells: (np.array) cells center to be displayed.
        atlaser: (tileAtlaser) tileAtlaser object containing the Atlas to be displayed.
        &#34;&#34;&#34;

        self.tiles = tiles

        if isinstance(database, pipapr.stitcher.tileStitcher):
            self.database = database.database
        elif isinstance(database, pd.DataFrame):
            self.database = database
        elif isinstance(database, str):
            self.database = pd.read_csv(database)
        else:
            raise TypeError(&#39;Error: unknown type for database.&#39;)

        self.nrow = tiles.nrow
        self.ncol = tiles.ncol
        self.loaded_ind = []
        self.loaded_tiles = {}
        self.segmentation = segmentation
        self.loaded_segmentation = {}
        self.cells = cells
        self.atlaser = atlaser

    def get_layers_all_tiles(self, downsample=1, **kwargs):
        &#34;&#34;&#34;
        Display all parsed tiles.

        Parameters
        ----------
        downsample: (int) downsampling parameter for APRSlicer
                            (1: full resolution, 2: 2x downsampling, 4: 4x downsampling..etc)
        kwargs: (dict) dictionary passed to Napari for custom option

        Returns
        -------
        None
        &#34;&#34;&#34;

        # Compute layers to be displayed by Napari
        layers = []

        # Convert downsample to level delta
        level_delta = int(-np.sign(downsample)*np.log2(np.abs(downsample)))

        for tile in self.tiles:
            # Load tile if not loaded, else use cached tile
            ind = np.ravel_multi_index((tile.row, tile.col), dims=(self.nrow, self.ncol))
            if self._is_tile_loaded(tile.row, tile.col):
                apr, parts = self.loaded_tiles[ind]
                if self.segmentation:
                    cc = self.loaded_segmentation[ind]
            else:
                tile.load_tile()
                apr, parts = tile.apr, tile.parts
                self.loaded_ind.append(ind)
                self.loaded_tiles[ind] = apr, parts
                if self.segmentation:
                    tile.load_segmentation()
                    cc = tile.parts_cc
                    self.loaded_segmentation[ind] = cc


            position = self._get_tile_position(tile.row, tile.col)
            if level_delta != 0:
                position = [x/downsample for x in position]
            layers.append(apr_to_napari_Image(apr, parts,
                                              mode=&#39;constant&#39;,
                                              name=&#39;Tile [{}, {}]&#39;.format(tile.row, tile.col),
                                              translate=position,
                                              opacity=0.7,
                                              level_delta=level_delta,
                                              **kwargs))
            if self.segmentation:
                layers.append(apr_to_napari_Labels(apr, cc,
                                                   mode=&#39;constant&#39;,
                                                   name=&#39;Segmentation [{}, {}]&#39;.format(tile.row, tile.col),
                                                   translate=position,
                                                   level_delta=level_delta,
                                                   opacity=0.7))
        if self.cells is not None:
            par = apr.get_parameters()
            layers.append(Points(self.cells, opacity=0.7, name=&#39;Cells center&#39;,
                                 scale=[par.dz/downsample, par.dx/downsample, par.dy/downsample]))

        if self.atlaser is not None:
            layers.append(Labels(self.atlaser.atlas, opacity=0.7, name=&#39;Atlas&#39;,
                                 scale=[self.atlaser.z_downsample/downsample,
                                        self.atlaser.y_downsample/downsample,
                                        self.atlaser.x_downsample/downsample]))

        return layers

    def display_all_tiles(self, pyramidal=True, downsample=1, color=False, **kwargs):
        &#34;&#34;&#34;
        Display all parsed tiles.

        Parameters
        ----------
        downsample: (int) downsampling parameter for APRSlicer
                            (1: full resolution, 2: 2x downsampling, 4: 4x downsampling..etc)
        kwargs: (dict) dictionary passed to Napari for custom option

        Returns
        -------
        None
        &#34;&#34;&#34;

        # Compute layers to be displayed by Napari
        layers = []

        # Convert downsample to level delta
        level_delta = int(-np.sign(downsample)*np.log2(np.abs(downsample)))

        for tile in self.tiles:
            # Load tile if not loaded, else use cached tile
            ind = np.ravel_multi_index((tile.row, tile.col), dims=(self.nrow, self.ncol))
            if self._is_tile_loaded(tile.row, tile.col):
                apr, parts = self.loaded_tiles[ind]
                if self.segmentation:
                    cc = self.loaded_segmentation[ind]
            else:
                tile.load_tile()
                apr, parts = tile.apr, tile.parts
                self.loaded_ind.append(ind)
                self.loaded_tiles[ind] = apr, parts
                if self.segmentation:
                    tile.load_segmentation()
                    cc = tile.parts_cc
                    self.loaded_segmentation[ind] = cc

            position = self._get_tile_position(tile.row, tile.col)

            if color:
                blending = &#39;additive&#39;
                if tile.col % 2:
                    if tile.row % 2:
                        cmap = &#39;red&#39;
                    else:
                        cmap = &#39;green&#39;
                else:
                    if tile.row % 2:
                        cmap = &#39;green&#39;
                    else:
                        cmap = &#39;red&#39;
            else:
                cmap = &#39;gray&#39;
                blending = &#39;translucent&#39;

            if level_delta != 0:
                position = [x/downsample for x in position]
            layers.append(apr_to_napari_Image(apr, parts,
                                              mode=&#39;constant&#39;,
                                              name=&#39;Tile [{}, {}]&#39;.format(tile.row, tile.col),
                                              translate=position,
                                              opacity=0.7,
                                              level_delta=level_delta,
                                              **kwargs))
            if self.segmentation:
                layers.append(apr_to_napari_Labels(apr, cc,
                                                   mode=&#39;constant&#39;,
                                                   name=&#39;Segmentation [{}, {}]&#39;.format(tile.row, tile.col),
                                                   translate=position,
                                                   level_delta=level_delta,
                                                   colormap=cmap,
                                                   blending=blending,
                                                   opacity=0.7))
        if self.cells is not None:
            par = apr.get_parameters()
            layers.append(Points(self.cells, opacity=0.7, name=&#39;Cells center&#39;,
                                 scale=[par.dz/downsample, par.dx/downsample, par.dy/downsample]))

        if self.atlaser is not None:
            layers.append(Labels(self.atlaser.atlas, opacity=0.7, name=&#39;Atlas&#39;,
                                 scale=[self.atlaser.z_downsample/downsample,
                                        self.atlaser.y_downsample/downsample,
                                        self.atlaser.x_downsample/downsample]))

        # Display layers
        if pyramidal:
            display_layers_pyramidal(layers, level_delta)
        else:
            display_layers(layers)

    def display_tiles(self, coords, pyramidal=True, downsample=1, color=False, **kwargs):
        &#34;&#34;&#34;
        Display tiles at position coords.

        Parameters
        ----------
        coords: (list) list of tuples (row, col) containing the tile coordinate to display.
        downsample: (int) downsampling parameter for APRSlicer
                            (1: full resolution, 2: 2x downsampling, 4: 4x downsampling..etc)
        kwargs: (dict) dictionary passed to Napari for custom option
        color: (bool) option to display in color

        Returns
        -------
        None
        &#34;&#34;&#34;

        # Compute layers to be displayed by Napari
        layers = []

        # Convert downsample to level delta
        level_delta = int(-np.sign(downsample) * np.log2(np.abs(downsample)))

        for tile in self.tiles:
            if (tile.row, tile.col) in coords:
                # Load tile if not loaded, else use cached tile
                ind = np.ravel_multi_index((tile.row, tile.col), dims=(self.nrow, self.ncol))
                if self._is_tile_loaded(tile.row, tile.col):
                    apr, parts = self.loaded_tiles[ind]
                    if self.segmentation:
                        cc = self.loaded_segmentation[ind]
                else:
                    tile.load_tile()
                    apr, parts = tile.apr, tile.parts
                    self.loaded_ind.append(ind)
                    self.loaded_tiles[ind] = apr, parts
                    if self.segmentation:
                        tile.load_segmentation()
                        cc = tile.parts_cc
                        self.loaded_segmentation[ind] = cc

                position = self._get_tile_position(tile.row, tile.col)
                if level_delta != 0:
                    position = [x / downsample for x in position]

                if color:
                    blending = &#39;additive&#39;
                    if tile.col % 2:
                        if tile.row % 2:
                            cmap = &#39;red&#39;
                        else:
                            cmap = &#39;green&#39;
                    else:
                        if tile.row % 2:
                            cmap = &#39;green&#39;
                        else:
                            cmap = &#39;red&#39;
                else:
                    cmap = &#39;gray&#39;
                    blending = &#39;translucent&#39;

                layers.append(apr_to_napari_Image(apr, parts,
                                                  mode=&#39;constant&#39;,
                                                  name=&#39;Tile [{}, {}]&#39;.format(tile.row, tile.col),
                                                  translate=position,
                                                  opacity=0.7,
                                                  level_delta=level_delta,
                                                  colormap=cmap,
                                                  blending=blending,
                                                  **kwargs))
                if self.segmentation:
                    layers.append(apr_to_napari_Labels(apr, cc,
                                                       mode=&#39;constant&#39;,
                                                       name=&#39;Segmentation [{}, {}]&#39;.format(tile.row, tile.col),
                                                       translate=position,
                                                       level_delta=level_delta,
                                                       opacity=0.7))
        if self.cells is not None:
            par = apr.get_parameters()
            layers.append(Points(self.cells, opacity=0.7, name=&#39;Cells center&#39;,
                                 scale=[par.dz / downsample, par.dx / downsample, par.dy / downsample]))

        if self.atlaser is not None:
            layers.append(Labels(self.atlaser.atlas, opacity=0.7, name=&#39;Atlas&#39;,
                                 scale=[self.atlaser.z_downsample / downsample,
                                        self.atlaser.y_downsample / downsample,
                                        self.atlaser.x_downsample / downsample]))

        # Display layers
        if pyramidal:
            display_layers_pyramidal(layers, level_delta)
        else:
            display_layers(layers)

    def check_stitching(self, downsample=8, color=False, **kwargs):

        # Compute layers to be displayed by Napari
        layers = []

        # Convert downsample to level delta
        level_delta = int(-np.sign(downsample)*np.log2(np.abs(downsample)))

        for tile in self.tiles:
            tile.lazy_load_tile(level_delta=level_delta)
            position = self._get_tile_position(tile.row, tile.col)

            if level_delta != 0:
                position = [x/downsample for x in position]

            if color:
                blending = &#39;additive&#39;
                if tile.col % 2:
                    if tile.row % 2:
                        cmap = &#39;red&#39;
                    else:
                        cmap = &#39;green&#39;
                else:
                    if tile.row % 2:
                        cmap = &#39;green&#39;
                    else:
                        cmap = &#39;red&#39;
            else:
                cmap = &#39;gray&#39;
                blending = &#39;translucent&#39;

            layers.append(Image(tile.lazy_data,
                              name=&#39;Tile [{}, {}]&#39;.format(tile.row, tile.col),
                              translate=position,
                              opacity=0.7,
                              colormap=cmap,
                              blending=blending,
                              **kwargs))

        display_layers(layers)


    def _is_tile_loaded(self, row, col):
        &#34;&#34;&#34;
        Returns True is tile is loaded, False otherwise.
        &#34;&#34;&#34;
        ind = np.ravel_multi_index((row, col), dims=(self.nrow, self.ncol))
        return ind in self.loaded_ind

    def _load_tile(self, row, col):
        &#34;&#34;&#34;
        Load the tile at position [row, col].
        &#34;&#34;&#34;
        df = self.database
        path = df[(df[&#39;row&#39;] == row) &amp; (df[&#39;col&#39;] == col)][&#39;path&#39;].values[0]
        if self.tiles.type == &#39;tiff2D&#39;:
            files = glob(os.path.join(path, &#39;*.tif&#39;))
            im = imread(files[0])
            u = np.zeros((len(files), *im.shape))
            u[0] = im
            files.pop(0)
            for i, file in enumerate(files):
                u[i+1] = imread(file)
            return self._get_apr(u)
        elif self.tiles.type == &#39;tiff3D&#39;:
            u = imread(path)
            return self._get_apr(u)
        elif self.tiles.type == &#39;apr&#39;:
            apr = pyapr.APR()
            parts = pyapr.ShortParticles()
            pyapr.io.read(path, apr, parts)
            u = (apr, parts)
            return u
        else:
            raise TypeError(&#39;Error: image type {} not supported.&#39;.format(self.type))

    def _get_tile_position(self, row, col):
        &#34;&#34;&#34;
        Parse tile position in the database.
        &#34;&#34;&#34;
        df = self.database
        tile_df = df[(df[&#39;row&#39;] == row) &amp; (df[&#39;col&#39;] == col)]
        px = tile_df[&#39;ABS_H&#39;].values[0]
        py = tile_df[&#39;ABS_V&#39;].values[0]
        pz = tile_df[&#39;ABS_D&#39;].values[0]

        return [pz, py, px]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pipapr.viewer.tileViewer.check_stitching"><code class="name flex">
<span>def <span class="ident">check_stitching</span></span>(<span>self, downsample=8, color=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_stitching(self, downsample=8, color=False, **kwargs):

    # Compute layers to be displayed by Napari
    layers = []

    # Convert downsample to level delta
    level_delta = int(-np.sign(downsample)*np.log2(np.abs(downsample)))

    for tile in self.tiles:
        tile.lazy_load_tile(level_delta=level_delta)
        position = self._get_tile_position(tile.row, tile.col)

        if level_delta != 0:
            position = [x/downsample for x in position]

        if color:
            blending = &#39;additive&#39;
            if tile.col % 2:
                if tile.row % 2:
                    cmap = &#39;red&#39;
                else:
                    cmap = &#39;green&#39;
            else:
                if tile.row % 2:
                    cmap = &#39;green&#39;
                else:
                    cmap = &#39;red&#39;
        else:
            cmap = &#39;gray&#39;
            blending = &#39;translucent&#39;

        layers.append(Image(tile.lazy_data,
                          name=&#39;Tile [{}, {}]&#39;.format(tile.row, tile.col),
                          translate=position,
                          opacity=0.7,
                          colormap=cmap,
                          blending=blending,
                          **kwargs))

    display_layers(layers)</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.tileViewer.display_all_tiles"><code class="name flex">
<span>def <span class="ident">display_all_tiles</span></span>(<span>self, pyramidal=True, downsample=1, color=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Display all parsed tiles.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>downsample</code></strong> :&ensp;<code>(int) downsampling parameter for APRSlicer</code></dt>
<dd>(1: full resolution, 2: 2x downsampling, 4: 4x downsampling..etc)</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>(dict) dictionary passed to Napari for custom option</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_all_tiles(self, pyramidal=True, downsample=1, color=False, **kwargs):
    &#34;&#34;&#34;
    Display all parsed tiles.

    Parameters
    ----------
    downsample: (int) downsampling parameter for APRSlicer
                        (1: full resolution, 2: 2x downsampling, 4: 4x downsampling..etc)
    kwargs: (dict) dictionary passed to Napari for custom option

    Returns
    -------
    None
    &#34;&#34;&#34;

    # Compute layers to be displayed by Napari
    layers = []

    # Convert downsample to level delta
    level_delta = int(-np.sign(downsample)*np.log2(np.abs(downsample)))

    for tile in self.tiles:
        # Load tile if not loaded, else use cached tile
        ind = np.ravel_multi_index((tile.row, tile.col), dims=(self.nrow, self.ncol))
        if self._is_tile_loaded(tile.row, tile.col):
            apr, parts = self.loaded_tiles[ind]
            if self.segmentation:
                cc = self.loaded_segmentation[ind]
        else:
            tile.load_tile()
            apr, parts = tile.apr, tile.parts
            self.loaded_ind.append(ind)
            self.loaded_tiles[ind] = apr, parts
            if self.segmentation:
                tile.load_segmentation()
                cc = tile.parts_cc
                self.loaded_segmentation[ind] = cc

        position = self._get_tile_position(tile.row, tile.col)

        if color:
            blending = &#39;additive&#39;
            if tile.col % 2:
                if tile.row % 2:
                    cmap = &#39;red&#39;
                else:
                    cmap = &#39;green&#39;
            else:
                if tile.row % 2:
                    cmap = &#39;green&#39;
                else:
                    cmap = &#39;red&#39;
        else:
            cmap = &#39;gray&#39;
            blending = &#39;translucent&#39;

        if level_delta != 0:
            position = [x/downsample for x in position]
        layers.append(apr_to_napari_Image(apr, parts,
                                          mode=&#39;constant&#39;,
                                          name=&#39;Tile [{}, {}]&#39;.format(tile.row, tile.col),
                                          translate=position,
                                          opacity=0.7,
                                          level_delta=level_delta,
                                          **kwargs))
        if self.segmentation:
            layers.append(apr_to_napari_Labels(apr, cc,
                                               mode=&#39;constant&#39;,
                                               name=&#39;Segmentation [{}, {}]&#39;.format(tile.row, tile.col),
                                               translate=position,
                                               level_delta=level_delta,
                                               colormap=cmap,
                                               blending=blending,
                                               opacity=0.7))
    if self.cells is not None:
        par = apr.get_parameters()
        layers.append(Points(self.cells, opacity=0.7, name=&#39;Cells center&#39;,
                             scale=[par.dz/downsample, par.dx/downsample, par.dy/downsample]))

    if self.atlaser is not None:
        layers.append(Labels(self.atlaser.atlas, opacity=0.7, name=&#39;Atlas&#39;,
                             scale=[self.atlaser.z_downsample/downsample,
                                    self.atlaser.y_downsample/downsample,
                                    self.atlaser.x_downsample/downsample]))

    # Display layers
    if pyramidal:
        display_layers_pyramidal(layers, level_delta)
    else:
        display_layers(layers)</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.tileViewer.display_tiles"><code class="name flex">
<span>def <span class="ident">display_tiles</span></span>(<span>self, coords, pyramidal=True, downsample=1, color=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Display tiles at position coords.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>coords: (list) list of tuples (row, col) containing the tile coordinate to display.</dt>
<dt><strong><code>downsample</code></strong> :&ensp;<code>(int) downsampling parameter for APRSlicer</code></dt>
<dd>(1: full resolution, 2: 2x downsampling, 4: 4x downsampling..etc)</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>(dict) dictionary passed to Napari for custom option</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>(bool) option to display in color</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_tiles(self, coords, pyramidal=True, downsample=1, color=False, **kwargs):
    &#34;&#34;&#34;
    Display tiles at position coords.

    Parameters
    ----------
    coords: (list) list of tuples (row, col) containing the tile coordinate to display.
    downsample: (int) downsampling parameter for APRSlicer
                        (1: full resolution, 2: 2x downsampling, 4: 4x downsampling..etc)
    kwargs: (dict) dictionary passed to Napari for custom option
    color: (bool) option to display in color

    Returns
    -------
    None
    &#34;&#34;&#34;

    # Compute layers to be displayed by Napari
    layers = []

    # Convert downsample to level delta
    level_delta = int(-np.sign(downsample) * np.log2(np.abs(downsample)))

    for tile in self.tiles:
        if (tile.row, tile.col) in coords:
            # Load tile if not loaded, else use cached tile
            ind = np.ravel_multi_index((tile.row, tile.col), dims=(self.nrow, self.ncol))
            if self._is_tile_loaded(tile.row, tile.col):
                apr, parts = self.loaded_tiles[ind]
                if self.segmentation:
                    cc = self.loaded_segmentation[ind]
            else:
                tile.load_tile()
                apr, parts = tile.apr, tile.parts
                self.loaded_ind.append(ind)
                self.loaded_tiles[ind] = apr, parts
                if self.segmentation:
                    tile.load_segmentation()
                    cc = tile.parts_cc
                    self.loaded_segmentation[ind] = cc

            position = self._get_tile_position(tile.row, tile.col)
            if level_delta != 0:
                position = [x / downsample for x in position]

            if color:
                blending = &#39;additive&#39;
                if tile.col % 2:
                    if tile.row % 2:
                        cmap = &#39;red&#39;
                    else:
                        cmap = &#39;green&#39;
                else:
                    if tile.row % 2:
                        cmap = &#39;green&#39;
                    else:
                        cmap = &#39;red&#39;
            else:
                cmap = &#39;gray&#39;
                blending = &#39;translucent&#39;

            layers.append(apr_to_napari_Image(apr, parts,
                                              mode=&#39;constant&#39;,
                                              name=&#39;Tile [{}, {}]&#39;.format(tile.row, tile.col),
                                              translate=position,
                                              opacity=0.7,
                                              level_delta=level_delta,
                                              colormap=cmap,
                                              blending=blending,
                                              **kwargs))
            if self.segmentation:
                layers.append(apr_to_napari_Labels(apr, cc,
                                                   mode=&#39;constant&#39;,
                                                   name=&#39;Segmentation [{}, {}]&#39;.format(tile.row, tile.col),
                                                   translate=position,
                                                   level_delta=level_delta,
                                                   opacity=0.7))
    if self.cells is not None:
        par = apr.get_parameters()
        layers.append(Points(self.cells, opacity=0.7, name=&#39;Cells center&#39;,
                             scale=[par.dz / downsample, par.dx / downsample, par.dy / downsample]))

    if self.atlaser is not None:
        layers.append(Labels(self.atlaser.atlas, opacity=0.7, name=&#39;Atlas&#39;,
                             scale=[self.atlaser.z_downsample / downsample,
                                    self.atlaser.y_downsample / downsample,
                                    self.atlaser.x_downsample / downsample]))

    # Display layers
    if pyramidal:
        display_layers_pyramidal(layers, level_delta)
    else:
        display_layers(layers)</code></pre>
</details>
</dd>
<dt id="pipapr.viewer.tileViewer.get_layers_all_tiles"><code class="name flex">
<span>def <span class="ident">get_layers_all_tiles</span></span>(<span>self, downsample=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Display all parsed tiles.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>downsample</code></strong> :&ensp;<code>(int) downsampling parameter for APRSlicer</code></dt>
<dd>(1: full resolution, 2: 2x downsampling, 4: 4x downsampling..etc)</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>(dict) dictionary passed to Napari for custom option</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_layers_all_tiles(self, downsample=1, **kwargs):
    &#34;&#34;&#34;
    Display all parsed tiles.

    Parameters
    ----------
    downsample: (int) downsampling parameter for APRSlicer
                        (1: full resolution, 2: 2x downsampling, 4: 4x downsampling..etc)
    kwargs: (dict) dictionary passed to Napari for custom option

    Returns
    -------
    None
    &#34;&#34;&#34;

    # Compute layers to be displayed by Napari
    layers = []

    # Convert downsample to level delta
    level_delta = int(-np.sign(downsample)*np.log2(np.abs(downsample)))

    for tile in self.tiles:
        # Load tile if not loaded, else use cached tile
        ind = np.ravel_multi_index((tile.row, tile.col), dims=(self.nrow, self.ncol))
        if self._is_tile_loaded(tile.row, tile.col):
            apr, parts = self.loaded_tiles[ind]
            if self.segmentation:
                cc = self.loaded_segmentation[ind]
        else:
            tile.load_tile()
            apr, parts = tile.apr, tile.parts
            self.loaded_ind.append(ind)
            self.loaded_tiles[ind] = apr, parts
            if self.segmentation:
                tile.load_segmentation()
                cc = tile.parts_cc
                self.loaded_segmentation[ind] = cc


        position = self._get_tile_position(tile.row, tile.col)
        if level_delta != 0:
            position = [x/downsample for x in position]
        layers.append(apr_to_napari_Image(apr, parts,
                                          mode=&#39;constant&#39;,
                                          name=&#39;Tile [{}, {}]&#39;.format(tile.row, tile.col),
                                          translate=position,
                                          opacity=0.7,
                                          level_delta=level_delta,
                                          **kwargs))
        if self.segmentation:
            layers.append(apr_to_napari_Labels(apr, cc,
                                               mode=&#39;constant&#39;,
                                               name=&#39;Segmentation [{}, {}]&#39;.format(tile.row, tile.col),
                                               translate=position,
                                               level_delta=level_delta,
                                               opacity=0.7))
    if self.cells is not None:
        par = apr.get_parameters()
        layers.append(Points(self.cells, opacity=0.7, name=&#39;Cells center&#39;,
                             scale=[par.dz/downsample, par.dx/downsample, par.dy/downsample]))

    if self.atlaser is not None:
        layers.append(Labels(self.atlaser.atlas, opacity=0.7, name=&#39;Atlas&#39;,
                             scale=[self.atlaser.z_downsample/downsample,
                                    self.atlaser.y_downsample/downsample,
                                    self.atlaser.x_downsample/downsample]))

    return layers</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pipapr" href="index.html">pipapr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pipapr.viewer.apr_to_napari_Image" href="#pipapr.viewer.apr_to_napari_Image">apr_to_napari_Image</a></code></li>
<li><code><a title="pipapr.viewer.apr_to_napari_Labels" href="#pipapr.viewer.apr_to_napari_Labels">apr_to_napari_Labels</a></code></li>
<li><code><a title="pipapr.viewer.compare_stitching" href="#pipapr.viewer.compare_stitching">compare_stitching</a></code></li>
<li><code><a title="pipapr.viewer.display_apr" href="#pipapr.viewer.display_apr">display_apr</a></code></li>
<li><code><a title="pipapr.viewer.display_apr_from_path" href="#pipapr.viewer.display_apr_from_path">display_apr_from_path</a></code></li>
<li><code><a title="pipapr.viewer.display_heatmap" href="#pipapr.viewer.display_heatmap">display_heatmap</a></code></li>
<li><code><a title="pipapr.viewer.display_layers" href="#pipapr.viewer.display_layers">display_layers</a></code></li>
<li><code><a title="pipapr.viewer.display_layers_pyramidal" href="#pipapr.viewer.display_layers_pyramidal">display_layers_pyramidal</a></code></li>
<li><code><a title="pipapr.viewer.display_segmentation" href="#pipapr.viewer.display_segmentation">display_segmentation</a></code></li>
<li><code><a title="pipapr.viewer.reconstruct_colored_projection" href="#pipapr.viewer.reconstruct_colored_projection">reconstruct_colored_projection</a></code></li>
<li><code><a title="pipapr.viewer.resolution_callback" href="#pipapr.viewer.resolution_callback">resolution_callback</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pipapr.viewer.tileViewer" href="#pipapr.viewer.tileViewer">tileViewer</a></code></h4>
<ul class="">
<li><code><a title="pipapr.viewer.tileViewer.check_stitching" href="#pipapr.viewer.tileViewer.check_stitching">check_stitching</a></code></li>
<li><code><a title="pipapr.viewer.tileViewer.display_all_tiles" href="#pipapr.viewer.tileViewer.display_all_tiles">display_all_tiles</a></code></li>
<li><code><a title="pipapr.viewer.tileViewer.display_tiles" href="#pipapr.viewer.tileViewer.display_tiles">display_tiles</a></code></li>
<li><code><a title="pipapr.viewer.tileViewer.get_layers_all_tiles" href="#pipapr.viewer.tileViewer.get_layers_all_tiles">get_layers_all_tiles</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>