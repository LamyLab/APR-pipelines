<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pipapr.converter API documentation</title>
<meta name="description" content="Submodule containing classes and functions relative to **converting** tiles to APR …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pipapr.converter</code></h1>
</header>
<section id="section-intro">
<p>Submodule containing classes and functions relative to <strong>converting</strong> tiles to APR.</p>
<p>The general workflow is first to parse tiles using a <em>parser</em> object and then convert using the tileConverter class.
This class is essentially a wrapper to pylibapr which allows to facilitate batch conversions and batch reconstructions.</p>
<p>By using this code you agree to the terms of the software license agreement.</p>
<p>© Copyright 2020 Wyss Center for Bio and Neuro Engineering – All rights reserved</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Submodule containing classes and functions relative to **converting** tiles to APR.

The general workflow is first to parse tiles using a *parser* object and then convert using the tileConverter class.
This class is essentially a wrapper to pylibapr which allows to facilitate batch conversions and batch reconstructions.

By using this code you agree to the terms of the software license agreement.

© Copyright 2020 Wyss Center for Bio and Neuro Engineering – All rights reserved
&#34;&#34;&#34;

import pipapr
import pyapr
import os
from pathlib import Path
from tqdm import tqdm
from skimage.io import imsave

class tileConverter():
    &#34;&#34;&#34;
    Class to convert tiles to APR or to tiff.
    &#34;&#34;&#34;

    def __init__(self,
                 tiles: (pipapr.parser.tileParser, pipapr.parser.baseParser)):
        &#34;&#34;&#34;

        Parameters
        ----------
        tiles: (tileParser or baseParser) parser object referencing tiles to be converted.
        &#34;&#34;&#34;

        if isinstance(tiles, pipapr.parser.tileParser):
            self.is_multitile = True # Not multitile
        else:
            self.is_multitile = False # Multitile

        self.tiles = tiles
        self.path = tiles.path
        self.n_tiles = tiles.n_tiles

        self.compression = 0
        self.bg = None
        self.quantization_factor = None

    def set_compression(self, quantization_factor=1, bg=108):
        &#34;&#34;&#34;
        Activate B3D compression for saving tiles.

        Parameters
        ----------
        quantization_factor: (int) quantization factor: the higher, the more compressed
                                (refer to B3D paper for more detail).
        bg: (int) background value: any value below this threshold will be set to the background value. This helps
                save up space by having the same value for the background (refer to B3D paper for more details).

        Returns
        -------
        None
        &#34;&#34;&#34;

        self.compression = True
        self.bg = bg
        self.quantization_factor = quantization_factor

    def deactivate_compression(self):
        &#34;&#34;&#34;
        Deactivate B3D compression when saving particles.

        Returns
        -------
        None
        &#34;&#34;&#34;

        self.compression = False
        self.bg = None
        self.quantization_factor = None

    def batch_convert_to_apr(self,
                             Ip_th=108,
                             rel_error=0.2,
                             gradient_smoothing=2,
                             dx=1,
                             dy=1,
                             dz=1,
                             path=None,
                             lazy_loading=True):
        &#34;&#34;&#34;
        Convert all parsed tiles to APR using auto-parameters.

        Parameters
        ----------
        Ip_th: (int) Intensity threshold
        rel_error: (float in [0, 1[) relative error bound
        gradient_smoothing: (float) B-Spline smoothing parameter (typically between 0 (no smoothing) and 10 (LOTS of
                            smoothing)
        dx: (float) PSF size in x, used to compute the gradient
        dy: (float) PSF size in y, used to compute the gradient
        dz: (float) PSF size in z, used to compute the gradient
        lazy_loading: (bool) if lazy_loading is true then the converter save mean tree particle which are necessary
                            for lazy loading of the APR. It will require about 1/7 more storage.

        Returns
        -------
        None
        &#34;&#34;&#34;

        if self.tiles.type == &#39;apr&#39;:
            raise TypeError(&#39;Error: data already in APR format.&#39;)

        # Safely create folder to save apr data
        if path is None:
            base_folder, _ = os.path.split(self.path)
            folder_apr = os.path.join(base_folder, &#39;APR&#39;)
        else:
            folder_apr = path
        Path(folder_apr).mkdir(parents=True, exist_ok=True)

        for tile in tqdm(self.tiles, desc=&#39;Converting tiles&#39;):
            tile.load_tile()

            # Set parameters
            par = pyapr.APRParameters()
            par.Ip_th = Ip_th
            par.rel_error = rel_error
            par.dx = dx
            par.dy = dy
            par.dz = dz
            par.gradient_smoothing = gradient_smoothing
            par.auto_parameters = True

            # Convert tile to APR and save
            apr = pyapr.APR()
            parts = pyapr.ShortParticles()
            converter = pyapr.converter.FloatConverter()
            converter.set_parameters(par)
            converter.verbose = True
            converter.get_apr(apr, tile.data)
            parts.sample_image(apr, tile.data)

            if self.compression:
                parts.set_compression_type(1)
                parts.set_quantization_factor(self.quantization_factor)
                parts.set_background(self.bg)

            if lazy_loading:
                tree_parts = pyapr.ShortParticles()
                pyapr.numerics.fill_tree_mean(apr, parts, tree_parts)
            else:
                tree_parts = None

            # Save converted data
            if not self.is_multitile:
                if tile.type == &#39;tiff2D&#39;:
                    basename, filename = os.path.split(tile.path[:-1])
                    pyapr.io.write(os.path.join(folder_apr, filename + &#39;.apr&#39;), apr, parts, tree_parts=tree_parts)
                else:
                    basename, filename = os.path.split(tile.path)
                    pyapr.io.write(os.path.join(folder_apr, filename[:-4] + &#39;.apr&#39;), apr, parts, tree_parts=tree_parts)
            else:
                filename = &#39;{}_{}.apr&#39;.format(tile.row, tile.col)
                pyapr.io.write(os.path.join(folder_apr, filename), apr, parts, tree_parts=tree_parts)

        if self.is_multitile:
            # Modify tileParser object to use APR instead
            self.tiles = pipapr.parser.tileParser(folder_apr,
                                                  frame_size=self.tiles.frame_size,
                                                  ftype=&#39;apr&#39;)

    def batch_reconstruct_pixel(self, mode=&#39;constant&#39;):
        &#34;&#34;&#34;
        Reconstruct all APR tiles to pixel data.

        Parameters
        ----------
        mode: (str) reconstruction mode, can be &#39;constant&#39;, &#39;smooth&#39; or &#39;level&#39;

        Returns
        -------
        None
        &#34;&#34;&#34;

        if self.tiles.type != &#39;apr&#39;:
            raise TypeError(&#39;Error: data not in APR format.&#39;)

        # Safely create folder to save apr data
        base_folder, _ = os.path.split(self.path)
        folder_tiff = os.path.join(base_folder, &#39;TIFF&#39;)
        Path(folder_tiff).mkdir(parents=True, exist_ok=True)

        for tile in tqdm(self.tiles, desc=&#39;Converting tiles&#39;):
            tile.load_tile()

            if mode == &#39;constant&#39;:
                data = pyapr.numerics.reconstruction.reconstruct_constant(tile.apr, tile.parts).squeeze()
            elif mode==&#39;smoth&#39;:
                data = pyapr.numerics.reconstruction.reconstruct_smooth(tile.apr, tile.parts).squeeze()
            elif mode==&#39;level&#39;:
                data = pyapr.numerics.reconstruction.reconstruct_level(tile.apr, tile.parts).squeeze()
            else:
                raise ValueError(&#39;Error: unknown mode for APR reconstruction.&#39;)

            # Save converted data
            if not self.is_multitile:
                basename, filename = os.path.split(tile.path)
                imsave(os.path.join(folder_tiff, filename[:-4] + &#39;.tif&#39;), data, check_contrast=False)
            else:
                filename = &#39;{}_{}.tif&#39;.format(tile.row, tile.col)
                imsave(os.path.join(folder_tiff, filename), data, check_contrast=False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pipapr.converter.tileConverter"><code class="flex name class">
<span>class <span class="ident">tileConverter</span></span>
<span>(</span><span>tiles: (<class '<a title="pipapr.parser.tileParser" href="parser.html#pipapr.parser.tileParser">tileParser</a>'>, <class '<a title="pipapr.parser.baseParser" href="parser.html#pipapr.parser.baseParser">baseParser</a>'>))</span>
</code></dt>
<dd>
<div class="desc"><p>Class to convert tiles to APR or to tiff.</p>
<h2 id="parameters">Parameters</h2>
<p>tiles: (tileParser or baseParser) parser object referencing tiles to be converted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class tileConverter():
    &#34;&#34;&#34;
    Class to convert tiles to APR or to tiff.
    &#34;&#34;&#34;

    def __init__(self,
                 tiles: (pipapr.parser.tileParser, pipapr.parser.baseParser)):
        &#34;&#34;&#34;

        Parameters
        ----------
        tiles: (tileParser or baseParser) parser object referencing tiles to be converted.
        &#34;&#34;&#34;

        if isinstance(tiles, pipapr.parser.tileParser):
            self.is_multitile = True # Not multitile
        else:
            self.is_multitile = False # Multitile

        self.tiles = tiles
        self.path = tiles.path
        self.n_tiles = tiles.n_tiles

        self.compression = 0
        self.bg = None
        self.quantization_factor = None

    def set_compression(self, quantization_factor=1, bg=108):
        &#34;&#34;&#34;
        Activate B3D compression for saving tiles.

        Parameters
        ----------
        quantization_factor: (int) quantization factor: the higher, the more compressed
                                (refer to B3D paper for more detail).
        bg: (int) background value: any value below this threshold will be set to the background value. This helps
                save up space by having the same value for the background (refer to B3D paper for more details).

        Returns
        -------
        None
        &#34;&#34;&#34;

        self.compression = True
        self.bg = bg
        self.quantization_factor = quantization_factor

    def deactivate_compression(self):
        &#34;&#34;&#34;
        Deactivate B3D compression when saving particles.

        Returns
        -------
        None
        &#34;&#34;&#34;

        self.compression = False
        self.bg = None
        self.quantization_factor = None

    def batch_convert_to_apr(self,
                             Ip_th=108,
                             rel_error=0.2,
                             gradient_smoothing=2,
                             dx=1,
                             dy=1,
                             dz=1,
                             path=None,
                             lazy_loading=True):
        &#34;&#34;&#34;
        Convert all parsed tiles to APR using auto-parameters.

        Parameters
        ----------
        Ip_th: (int) Intensity threshold
        rel_error: (float in [0, 1[) relative error bound
        gradient_smoothing: (float) B-Spline smoothing parameter (typically between 0 (no smoothing) and 10 (LOTS of
                            smoothing)
        dx: (float) PSF size in x, used to compute the gradient
        dy: (float) PSF size in y, used to compute the gradient
        dz: (float) PSF size in z, used to compute the gradient
        lazy_loading: (bool) if lazy_loading is true then the converter save mean tree particle which are necessary
                            for lazy loading of the APR. It will require about 1/7 more storage.

        Returns
        -------
        None
        &#34;&#34;&#34;

        if self.tiles.type == &#39;apr&#39;:
            raise TypeError(&#39;Error: data already in APR format.&#39;)

        # Safely create folder to save apr data
        if path is None:
            base_folder, _ = os.path.split(self.path)
            folder_apr = os.path.join(base_folder, &#39;APR&#39;)
        else:
            folder_apr = path
        Path(folder_apr).mkdir(parents=True, exist_ok=True)

        for tile in tqdm(self.tiles, desc=&#39;Converting tiles&#39;):
            tile.load_tile()

            # Set parameters
            par = pyapr.APRParameters()
            par.Ip_th = Ip_th
            par.rel_error = rel_error
            par.dx = dx
            par.dy = dy
            par.dz = dz
            par.gradient_smoothing = gradient_smoothing
            par.auto_parameters = True

            # Convert tile to APR and save
            apr = pyapr.APR()
            parts = pyapr.ShortParticles()
            converter = pyapr.converter.FloatConverter()
            converter.set_parameters(par)
            converter.verbose = True
            converter.get_apr(apr, tile.data)
            parts.sample_image(apr, tile.data)

            if self.compression:
                parts.set_compression_type(1)
                parts.set_quantization_factor(self.quantization_factor)
                parts.set_background(self.bg)

            if lazy_loading:
                tree_parts = pyapr.ShortParticles()
                pyapr.numerics.fill_tree_mean(apr, parts, tree_parts)
            else:
                tree_parts = None

            # Save converted data
            if not self.is_multitile:
                if tile.type == &#39;tiff2D&#39;:
                    basename, filename = os.path.split(tile.path[:-1])
                    pyapr.io.write(os.path.join(folder_apr, filename + &#39;.apr&#39;), apr, parts, tree_parts=tree_parts)
                else:
                    basename, filename = os.path.split(tile.path)
                    pyapr.io.write(os.path.join(folder_apr, filename[:-4] + &#39;.apr&#39;), apr, parts, tree_parts=tree_parts)
            else:
                filename = &#39;{}_{}.apr&#39;.format(tile.row, tile.col)
                pyapr.io.write(os.path.join(folder_apr, filename), apr, parts, tree_parts=tree_parts)

        if self.is_multitile:
            # Modify tileParser object to use APR instead
            self.tiles = pipapr.parser.tileParser(folder_apr,
                                                  frame_size=self.tiles.frame_size,
                                                  ftype=&#39;apr&#39;)

    def batch_reconstruct_pixel(self, mode=&#39;constant&#39;):
        &#34;&#34;&#34;
        Reconstruct all APR tiles to pixel data.

        Parameters
        ----------
        mode: (str) reconstruction mode, can be &#39;constant&#39;, &#39;smooth&#39; or &#39;level&#39;

        Returns
        -------
        None
        &#34;&#34;&#34;

        if self.tiles.type != &#39;apr&#39;:
            raise TypeError(&#39;Error: data not in APR format.&#39;)

        # Safely create folder to save apr data
        base_folder, _ = os.path.split(self.path)
        folder_tiff = os.path.join(base_folder, &#39;TIFF&#39;)
        Path(folder_tiff).mkdir(parents=True, exist_ok=True)

        for tile in tqdm(self.tiles, desc=&#39;Converting tiles&#39;):
            tile.load_tile()

            if mode == &#39;constant&#39;:
                data = pyapr.numerics.reconstruction.reconstruct_constant(tile.apr, tile.parts).squeeze()
            elif mode==&#39;smoth&#39;:
                data = pyapr.numerics.reconstruction.reconstruct_smooth(tile.apr, tile.parts).squeeze()
            elif mode==&#39;level&#39;:
                data = pyapr.numerics.reconstruction.reconstruct_level(tile.apr, tile.parts).squeeze()
            else:
                raise ValueError(&#39;Error: unknown mode for APR reconstruction.&#39;)

            # Save converted data
            if not self.is_multitile:
                basename, filename = os.path.split(tile.path)
                imsave(os.path.join(folder_tiff, filename[:-4] + &#39;.tif&#39;), data, check_contrast=False)
            else:
                filename = &#39;{}_{}.tif&#39;.format(tile.row, tile.col)
                imsave(os.path.join(folder_tiff, filename), data, check_contrast=False)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pipapr.converter.tileConverter.batch_convert_to_apr"><code class="name flex">
<span>def <span class="ident">batch_convert_to_apr</span></span>(<span>self, Ip_th=108, rel_error=0.2, gradient_smoothing=2, dx=1, dy=1, dz=1, path=None, lazy_loading=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert all parsed tiles to APR using auto-parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Ip_th</code></strong> :&ensp;<code>(int) Intensity threshold</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>rel_error</code></strong> :&ensp;<code>(float in [0, 1[) relative error bound</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>gradient_smoothing</code></strong> :&ensp;<code>(float) B-Spline smoothing parameter (typically between 0 (no smoothing) and 10 (LOTS of</code></dt>
<dd>smoothing)</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>(float) PSF size in x, used to compute the gradient</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>dy</code></strong> :&ensp;<code>(float) PSF size in y, used to compute the gradient</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>dz</code></strong> :&ensp;<code>(float) PSF size in z, used to compute the gradient</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>lazy_loading</code></strong> :&ensp;<code>(bool) if lazy_loading is true then the converter save mean tree particle which are necessary</code></dt>
<dd>for lazy loading of the APR. It will require about 1/7 more storage.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def batch_convert_to_apr(self,
                         Ip_th=108,
                         rel_error=0.2,
                         gradient_smoothing=2,
                         dx=1,
                         dy=1,
                         dz=1,
                         path=None,
                         lazy_loading=True):
    &#34;&#34;&#34;
    Convert all parsed tiles to APR using auto-parameters.

    Parameters
    ----------
    Ip_th: (int) Intensity threshold
    rel_error: (float in [0, 1[) relative error bound
    gradient_smoothing: (float) B-Spline smoothing parameter (typically between 0 (no smoothing) and 10 (LOTS of
                        smoothing)
    dx: (float) PSF size in x, used to compute the gradient
    dy: (float) PSF size in y, used to compute the gradient
    dz: (float) PSF size in z, used to compute the gradient
    lazy_loading: (bool) if lazy_loading is true then the converter save mean tree particle which are necessary
                        for lazy loading of the APR. It will require about 1/7 more storage.

    Returns
    -------
    None
    &#34;&#34;&#34;

    if self.tiles.type == &#39;apr&#39;:
        raise TypeError(&#39;Error: data already in APR format.&#39;)

    # Safely create folder to save apr data
    if path is None:
        base_folder, _ = os.path.split(self.path)
        folder_apr = os.path.join(base_folder, &#39;APR&#39;)
    else:
        folder_apr = path
    Path(folder_apr).mkdir(parents=True, exist_ok=True)

    for tile in tqdm(self.tiles, desc=&#39;Converting tiles&#39;):
        tile.load_tile()

        # Set parameters
        par = pyapr.APRParameters()
        par.Ip_th = Ip_th
        par.rel_error = rel_error
        par.dx = dx
        par.dy = dy
        par.dz = dz
        par.gradient_smoothing = gradient_smoothing
        par.auto_parameters = True

        # Convert tile to APR and save
        apr = pyapr.APR()
        parts = pyapr.ShortParticles()
        converter = pyapr.converter.FloatConverter()
        converter.set_parameters(par)
        converter.verbose = True
        converter.get_apr(apr, tile.data)
        parts.sample_image(apr, tile.data)

        if self.compression:
            parts.set_compression_type(1)
            parts.set_quantization_factor(self.quantization_factor)
            parts.set_background(self.bg)

        if lazy_loading:
            tree_parts = pyapr.ShortParticles()
            pyapr.numerics.fill_tree_mean(apr, parts, tree_parts)
        else:
            tree_parts = None

        # Save converted data
        if not self.is_multitile:
            if tile.type == &#39;tiff2D&#39;:
                basename, filename = os.path.split(tile.path[:-1])
                pyapr.io.write(os.path.join(folder_apr, filename + &#39;.apr&#39;), apr, parts, tree_parts=tree_parts)
            else:
                basename, filename = os.path.split(tile.path)
                pyapr.io.write(os.path.join(folder_apr, filename[:-4] + &#39;.apr&#39;), apr, parts, tree_parts=tree_parts)
        else:
            filename = &#39;{}_{}.apr&#39;.format(tile.row, tile.col)
            pyapr.io.write(os.path.join(folder_apr, filename), apr, parts, tree_parts=tree_parts)

    if self.is_multitile:
        # Modify tileParser object to use APR instead
        self.tiles = pipapr.parser.tileParser(folder_apr,
                                              frame_size=self.tiles.frame_size,
                                              ftype=&#39;apr&#39;)</code></pre>
</details>
</dd>
<dt id="pipapr.converter.tileConverter.batch_reconstruct_pixel"><code class="name flex">
<span>def <span class="ident">batch_reconstruct_pixel</span></span>(<span>self, mode='constant')</span>
</code></dt>
<dd>
<div class="desc"><p>Reconstruct all APR tiles to pixel data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>(str) reconstruction mode, can be 'constant', 'smooth'</code> or <code>'level'</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def batch_reconstruct_pixel(self, mode=&#39;constant&#39;):
    &#34;&#34;&#34;
    Reconstruct all APR tiles to pixel data.

    Parameters
    ----------
    mode: (str) reconstruction mode, can be &#39;constant&#39;, &#39;smooth&#39; or &#39;level&#39;

    Returns
    -------
    None
    &#34;&#34;&#34;

    if self.tiles.type != &#39;apr&#39;:
        raise TypeError(&#39;Error: data not in APR format.&#39;)

    # Safely create folder to save apr data
    base_folder, _ = os.path.split(self.path)
    folder_tiff = os.path.join(base_folder, &#39;TIFF&#39;)
    Path(folder_tiff).mkdir(parents=True, exist_ok=True)

    for tile in tqdm(self.tiles, desc=&#39;Converting tiles&#39;):
        tile.load_tile()

        if mode == &#39;constant&#39;:
            data = pyapr.numerics.reconstruction.reconstruct_constant(tile.apr, tile.parts).squeeze()
        elif mode==&#39;smoth&#39;:
            data = pyapr.numerics.reconstruction.reconstruct_smooth(tile.apr, tile.parts).squeeze()
        elif mode==&#39;level&#39;:
            data = pyapr.numerics.reconstruction.reconstruct_level(tile.apr, tile.parts).squeeze()
        else:
            raise ValueError(&#39;Error: unknown mode for APR reconstruction.&#39;)

        # Save converted data
        if not self.is_multitile:
            basename, filename = os.path.split(tile.path)
            imsave(os.path.join(folder_tiff, filename[:-4] + &#39;.tif&#39;), data, check_contrast=False)
        else:
            filename = &#39;{}_{}.tif&#39;.format(tile.row, tile.col)
            imsave(os.path.join(folder_tiff, filename), data, check_contrast=False)</code></pre>
</details>
</dd>
<dt id="pipapr.converter.tileConverter.deactivate_compression"><code class="name flex">
<span>def <span class="ident">deactivate_compression</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deactivate B3D compression when saving particles.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deactivate_compression(self):
    &#34;&#34;&#34;
    Deactivate B3D compression when saving particles.

    Returns
    -------
    None
    &#34;&#34;&#34;

    self.compression = False
    self.bg = None
    self.quantization_factor = None</code></pre>
</details>
</dd>
<dt id="pipapr.converter.tileConverter.set_compression"><code class="name flex">
<span>def <span class="ident">set_compression</span></span>(<span>self, quantization_factor=1, bg=108)</span>
</code></dt>
<dd>
<div class="desc"><p>Activate B3D compression for saving tiles.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>quantization_factor</code></strong> :&ensp;<code>(int) quantization factor: the higher, the more compressed</code></dt>
<dd>(refer to B3D paper for more detail).</dd>
<dt><strong><code>bg</code></strong> :&ensp;<code>(int) background value: any value below this threshold will be set to the background value. This helps</code></dt>
<dd>save up space by having the same value for the background (refer to B3D paper for more details).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_compression(self, quantization_factor=1, bg=108):
    &#34;&#34;&#34;
    Activate B3D compression for saving tiles.

    Parameters
    ----------
    quantization_factor: (int) quantization factor: the higher, the more compressed
                            (refer to B3D paper for more detail).
    bg: (int) background value: any value below this threshold will be set to the background value. This helps
            save up space by having the same value for the background (refer to B3D paper for more details).

    Returns
    -------
    None
    &#34;&#34;&#34;

    self.compression = True
    self.bg = bg
    self.quantization_factor = quantization_factor</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pipapr" href="index.html">pipapr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pipapr.converter.tileConverter" href="#pipapr.converter.tileConverter">tileConverter</a></code></h4>
<ul class="">
<li><code><a title="pipapr.converter.tileConverter.batch_convert_to_apr" href="#pipapr.converter.tileConverter.batch_convert_to_apr">batch_convert_to_apr</a></code></li>
<li><code><a title="pipapr.converter.tileConverter.batch_reconstruct_pixel" href="#pipapr.converter.tileConverter.batch_reconstruct_pixel">batch_reconstruct_pixel</a></code></li>
<li><code><a title="pipapr.converter.tileConverter.deactivate_compression" href="#pipapr.converter.tileConverter.deactivate_compression">deactivate_compression</a></code></li>
<li><code><a title="pipapr.converter.tileConverter.set_compression" href="#pipapr.converter.tileConverter.set_compression">set_compression</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>