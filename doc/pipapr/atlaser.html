<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pipapr.atlaser API documentation</title>
<meta name="description" content="Submodule containing classes and functions relative to **atlasing** …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pipapr.atlaser</code></h1>
</header>
<section id="section-intro">
<p>Submodule containing classes and functions relative to <strong>atlasing</strong>.</p>
<p>This submodule is essentially a wrapper to Brainreg (<a href="https://github.com/brainglobe/brainreg">https://github.com/brainglobe/brainreg</a>) for atlasing and
Allen Brain Atlas for ontology analysis. It contains many convenience method for manipulating data
(per region, per superpixel, etc.).</p>
<p>By using this code you agree to the terms of the software license agreement.</p>
<p>© Copyright 2020 Wyss Center for Bio and Neuro Engineering – All rights reserved</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Submodule containing classes and functions relative to **atlasing**.

This submodule is essentially a wrapper to Brainreg (https://github.com/brainglobe/brainreg) for atlasing and
Allen Brain Atlas for ontology analysis. It contains many convenience method for manipulating data
(per region, per superpixel, etc.).

By using this code you agree to the terms of the software license agreement.

© Copyright 2020 Wyss Center for Bio and Neuro Engineering – All rights reserved
&#34;&#34;&#34;

import pandas as pd
from skimage.io import imread, imsave
from skimage.filters import gaussian
import pipapr
import numpy as np
import os
from pathlib import Path
from allensdk.core.reference_space_cache import ReferenceSpaceCache

class tileAtlaser():
    &#34;&#34;&#34;
    Class used for registering a dataset to the Atlas and do some post processing using the Atlas (e.g count cells
    per region).

    It can be instantiated using a tileMerger object (for registration using Brainreg) or directly with a
    previously registered Atlas.
    &#34;&#34;&#34;

    def __init__(self,
                 original_pixel_size: (np.array, list),
                 downsample: int,
                 atlas=None,
                 merged_data=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        original_pixel_size: (np.array, list) pixel size in µm on the original data
        downsample: (int) downsampling used by APRSlicer to reconstruct the lower resolution pixel data used
                            for registration to the Atlas.
        atlas: (np.array, str) atlas data or path for loading the atlas data
        merger: (tileMerger) tileMerger object
        &#34;&#34;&#34;

        self.downsample = downsample
        self.pixel_size_registered_atlas = np.array([25, 25, 25])
        self.pixel_size_data = np.array(original_pixel_size) # Z Y X
        self.merged_data = merged_data
        self.z_downsample = self.pixel_size_registered_atlas[0] / self.pixel_size_data[0]
        self.y_downsample = self.pixel_size_registered_atlas[1] / self.pixel_size_data[1]
        self.x_downsample = self.pixel_size_registered_atlas[2] / self.pixel_size_data[2]

        if atlas is not None:
            if isinstance(atlas, str):
                self.load_atlas(atlas)
            elif isinstance(atlas, np.array):
                self.atlas = atlas
            else:
                raise TypeError(&#39;Error: atlas must be a path or a numpy array.&#39;)

    @classmethod
    def from_merger(cls,
                   merger: pipapr.stitcher.tileMerger,
                   original_pixel_size: (np.array, list)):
        &#34;&#34;&#34;
        Constructor from a tileMerger object. Typically to perform the registration to the Atlas on
        autofluorescence data.

        Parameters
        ----------
        merger: (tileMerger) tileMerger object
        original_pixel_size: (np.array, list) pixel size in µm on the original data

        Returns
        -------
        tileAtlaser object
        &#34;&#34;&#34;

        return cls(original_pixel_size=original_pixel_size,
                   downsample=merger.downsample,
                   atlas=None,
                   merged_data=merger.merged_data)

    @classmethod
    def from_atlas(cls,
                  atlas: (np.array, str),
                  downsample,
                  original_pixel_size: (np.array, list)):
        &#34;&#34;&#34;
        Constructor from a previously computed Atlas. Typically to perform postprocessing using an Atlas (e.g.
        count cells per brain region).

        Parameters
        ----------
        atlas: (np.array, str) atlas data or path for loading the atlas data
        downsample: (int) downsampling used by APRSlicer to reconstruct the lower resolution pixel data used
                            for registration to the Atlas.
        original_pixel_size: (np.array, list) pixel size in µm on the original data

        Returns
        -------

        &#34;&#34;&#34;

        return cls(original_pixel_size=original_pixel_size,
                   downsample=downsample,
                   atlas=atlas,
                   merged_data=None)


    def load_atlas(self, path):
        &#34;&#34;&#34;
        Function to load a previously computed atlas.

        Parameters
        ----------
        path: (str) path to the registered atlas file.

        Returns
        -------
        None
        &#34;&#34;&#34;

        self.atlas = imread(path)

    def register_to_atlas(self,
                          output_dir=&#39;./&#39;,
                          orientation=&#39;spr&#39;,
                          merged_data_filename=&#39;merged_data.tif&#39;,
                          debug=False,
                          params=None):
        &#34;&#34;&#34;
        Function to compute the registration to the Atlas. It is just a wrapper to call brainreg.

        Parameters
        ----------
        output_dir: (str) output directory to save atlas
        orientation: (str) orientation of the input data with respect to the origin in Z,Y,X order. E.g. &#39;spr&#39; means
                        superior (so going from origin to z = zlim we go from superior to inferior), posterior
                        (so going from origin to y = ylim we go from posterior to anterior part) and right (so going
                         from origin to x = xlim we go from right to left part)
        merged_data_filename: (str) named of the merged array (Brainreg reads data from files so we need to save
                                the merged volume beforehand.
        params: (dict) dictionary with keys as brainreg options and values as parameters (see here:
                https://docs.brainglobe.info/brainreg/user-guide/parameters)

        Returns
        -------
        None
        &#34;&#34;&#34;

        # Create directories if they do not exist
        atlas_dir = os.path.join(output_dir, &#39;atlas&#39;)
        Path(atlas_dir).mkdir(parents=True, exist_ok=True)

        # If merged_data is a path we ask brainreg to work on this file
        if isinstance(self.merged_data, str):
            path_merged_data = self.merged_data
        # Else it means it&#39;s an array so we have to save it first
        else:
            path_merged_data = os.path.join(output_dir, merged_data_filename)
            imsave(path_merged_data, self.merged_data)

        command = &#39;brainreg {} {} -v {} {} {} --orientation {} --save-original-orientation&#39;.format(&#39;&#34;&#39; + path_merged_data + &#39;&#34;&#39;,
                                                            &#39;&#34;&#39; + atlas_dir + &#39;&#34;&#39;,
                                                            self.pixel_size_data[0]*self.downsample,
                                                            self.pixel_size_data[1]*self.downsample,
                                                            self.pixel_size_data[2]*self.downsample,
                                                            orientation)

        if params is not None:
            for key, value in params.items():
                command += &#39; --{} {}&#39;.format(key, value)

        if debug:
            command += &#39; --debug&#39;

        # Execute brainreg
        os.system(command)

        self.load_atlas(os.path.join(atlas_dir, &#39;registered_atlas.tiff&#39;))

    def get_cells_id(self, cells):
        &#34;&#34;&#34;
        Returns the Allen Brain Atlas region ID for each cell.

        Parameters
        ----------
        cells: (array) cell positions.

        Returns
        -------
        labels: (array) containing the cell region ID.
        &#34;&#34;&#34;
        labels = self.atlas[np.floor(cells.cells[:, 0]/self.z_downsample).astype(&#39;uint64&#39;),
                        np.floor(cells.cells[:, 1]/self.y_downsample).astype(&#39;uint64&#39;),
                        np.floor(cells.cells[:, 2]/self.x_downsample).astype(&#39;uint64&#39;)]

        return labels

    def get_loc_id(self, x, y, z):
        &#34;&#34;&#34;
        Return the ID (brain region) of a given position (typically to retrieve cell position in the brain).

        Parameters
        ----------
        x: (int) x position
        y: (int) y position
        z: (int) z position

        Returns
        -------
        ID at the queried position.
        &#34;&#34;&#34;
        return self.atlas[int(z / self.z_downsample), int(y / self.y_downsample), int(x / self.x_downsample)]

    def get_ontology_mapping(self, labels, n=0):
        &#34;&#34;&#34;
        Get the mapping between area ID and name with Allen SDK.

        Parameters
        ----------
        labels: (array) array of labels to group by ID and fetch area name.
        n: (int) number of parent area to group for.

        Returns
        -------
        area_count: (dict) area names with the counts.
        &#34;&#34;&#34;
        rspc = ReferenceSpaceCache(25, &#39;annotation/ccf_2017&#39;, manifest=&#39;manifest.json&#39;)
        tree = rspc.get_structure_tree(structure_graph_id=1)
        name_map = tree.get_name_map()
        ancestor_map = tree.get_ancestor_id_map()
        area_count = {}
        n_not_found = 0
        area_unknown = {}
        id_count = {}
        for l in labels:
            try:
                ids = ancestor_map[int(l)]
            except KeyError:
                n_not_found += 1
                if &#39;unknown&#39; not in area_count:
                    area_count[&#39;unknown&#39;] = 1
                else:
                    area_count[&#39;unknown&#39;] += 1
                if int(l) not in area_unknown:
                    area_unknown[int(l)] = 1
                else:
                    area_unknown[int(l)] += 1
                continue

            if len(ids) &lt;= 2:
                id = ids[0]
            elif len(ids) &lt;= n:
                id = ids[-2]
            else:
                id = ids[n if n &lt; len(ids) - 1 else n - 1]

            # Get the name and store it
            name = name_map[id]
            if name not in area_count:
                area_count[name] = 1
            else:
                area_count[name] += 1

        # Display summary
        if n == 0:
            if n_not_found &gt; 0:
                print(&#39;\nUnknown ontology ID found for {} objects ({:0.2f}%).&#39;.format(n_not_found,
                                                                                      n_not_found/len(labels)*100))
                print(&#39;Unknown ontology IDs and occurrences:\n&#39;)
                print(area_unknown)
            else:
                print(&#39;\nAll objects were assigned to an atlas ontology category.\n&#39;)

        return pd.DataFrame.from_dict(area_count, orient=&#39;index&#39;)

    def get_cells_number_per_region(self, cells_id):
        &#34;&#34;&#34;
        Retuns the number of cell per region.

        Parameters
        ----------
        cells_id: (array) cells ID (typically computed by self.get_cells_id())

        Returns
        -------
        heatmap: (array) 3D array where each brain region value is the number of cells contained in this region.
        &#34;&#34;&#34;

        # Remove 0s
        cells_id = np.delete(cells_id, cells_id==0)
        id_count = {}
        for id in cells_id:
            if id not in id_count:
                id_count[id] = 1
            else:
                id_count[id] += 1

        heatmap = np.zeros_like(self.atlas)
        for id, counts in id_count.items():
            heatmap[self.atlas==id] = counts

        return heatmap

    def get_cells_density_per_region(self, cells_id):
        &#34;&#34;&#34;
        Retuns the cell density (number of cell per voxel) per region.

        Parameters
        ----------
        cells_id: (array) cells ID (typically computed by self.get_cells_id())

        Returns
        -------
        heatmap: (array) 3D array where each brain region value is the cell density in this region.
        &#34;&#34;&#34;

        # Remove 0s
        cells_id = np.delete(cells_id, cells_id == 0)
        id_count = {}
        for id in cells_id:
            if id not in id_count:
                id_count[id] = 1
            else:
                id_count[id] += 1

        heatmap = np.zeros_like(self.atlas, dtype=&#39;float64&#39;)
        for id, counts in id_count.items():
            tmp = (self.atlas == id)
            heatmap[tmp] = counts/np.sum(tmp)

        return heatmap

    def get_cells_density(self, cells, kernel_size):
        &#34;&#34;&#34;
        Retuns the cell density (local average number of cell per voxel). The local average is computed using a gaussian
        kernel.

        Parameters
        ----------
        cells: (array) cell positions
        kernel_size: (int) radius of the gaussian for local cell density estimation

        Returns
        -------

        &#34;&#34;&#34;

        heatmap = np.zeros((self.atlas.shape)).astype(int)
        for i in tqdm(range(cells.shape[0]), desc=&#39;Building density map..&#39;):
            z = int(cells[i, 0]/self.z_downsample)
            y = int(cells[i, 1]/self.y_downsample)
            x = int(cells[i, 2]/self.x_downsample)
            heatmap[z, y, x] = 1

        return gaussian(heatmap, sigma=kernel_size)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pipapr.atlaser.tileAtlaser"><code class="flex name class">
<span>class <span class="ident">tileAtlaser</span></span>
<span>(</span><span>original_pixel_size: (<built-in function array>, <class 'list'>), downsample: int, atlas=None, merged_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used for registering a dataset to the Atlas and do some post processing using the Atlas (e.g count cells
per region).</p>
<p>It can be instantiated using a tileMerger object (for registration using Brainreg) or directly with a
previously registered Atlas.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>original_pixel_size</code></strong> :&ensp;<code>(np.array, list) pixel size in µm on the original data</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>downsample</code></strong> :&ensp;<code>(int) downsampling used by APRSlicer to reconstruct the lower resolution pixel data used</code></dt>
<dd>for registration to the Atlas.</dd>
<dt><strong><code>atlas</code></strong> :&ensp;<code>(np.array, str) atlas data</code> or <code>path for loading the atlas data</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>merger</code></strong> :&ensp;<code>(tileMerger) tileMerger object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class tileAtlaser():
    &#34;&#34;&#34;
    Class used for registering a dataset to the Atlas and do some post processing using the Atlas (e.g count cells
    per region).

    It can be instantiated using a tileMerger object (for registration using Brainreg) or directly with a
    previously registered Atlas.
    &#34;&#34;&#34;

    def __init__(self,
                 original_pixel_size: (np.array, list),
                 downsample: int,
                 atlas=None,
                 merged_data=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        original_pixel_size: (np.array, list) pixel size in µm on the original data
        downsample: (int) downsampling used by APRSlicer to reconstruct the lower resolution pixel data used
                            for registration to the Atlas.
        atlas: (np.array, str) atlas data or path for loading the atlas data
        merger: (tileMerger) tileMerger object
        &#34;&#34;&#34;

        self.downsample = downsample
        self.pixel_size_registered_atlas = np.array([25, 25, 25])
        self.pixel_size_data = np.array(original_pixel_size) # Z Y X
        self.merged_data = merged_data
        self.z_downsample = self.pixel_size_registered_atlas[0] / self.pixel_size_data[0]
        self.y_downsample = self.pixel_size_registered_atlas[1] / self.pixel_size_data[1]
        self.x_downsample = self.pixel_size_registered_atlas[2] / self.pixel_size_data[2]

        if atlas is not None:
            if isinstance(atlas, str):
                self.load_atlas(atlas)
            elif isinstance(atlas, np.array):
                self.atlas = atlas
            else:
                raise TypeError(&#39;Error: atlas must be a path or a numpy array.&#39;)

    @classmethod
    def from_merger(cls,
                   merger: pipapr.stitcher.tileMerger,
                   original_pixel_size: (np.array, list)):
        &#34;&#34;&#34;
        Constructor from a tileMerger object. Typically to perform the registration to the Atlas on
        autofluorescence data.

        Parameters
        ----------
        merger: (tileMerger) tileMerger object
        original_pixel_size: (np.array, list) pixel size in µm on the original data

        Returns
        -------
        tileAtlaser object
        &#34;&#34;&#34;

        return cls(original_pixel_size=original_pixel_size,
                   downsample=merger.downsample,
                   atlas=None,
                   merged_data=merger.merged_data)

    @classmethod
    def from_atlas(cls,
                  atlas: (np.array, str),
                  downsample,
                  original_pixel_size: (np.array, list)):
        &#34;&#34;&#34;
        Constructor from a previously computed Atlas. Typically to perform postprocessing using an Atlas (e.g.
        count cells per brain region).

        Parameters
        ----------
        atlas: (np.array, str) atlas data or path for loading the atlas data
        downsample: (int) downsampling used by APRSlicer to reconstruct the lower resolution pixel data used
                            for registration to the Atlas.
        original_pixel_size: (np.array, list) pixel size in µm on the original data

        Returns
        -------

        &#34;&#34;&#34;

        return cls(original_pixel_size=original_pixel_size,
                   downsample=downsample,
                   atlas=atlas,
                   merged_data=None)


    def load_atlas(self, path):
        &#34;&#34;&#34;
        Function to load a previously computed atlas.

        Parameters
        ----------
        path: (str) path to the registered atlas file.

        Returns
        -------
        None
        &#34;&#34;&#34;

        self.atlas = imread(path)

    def register_to_atlas(self,
                          output_dir=&#39;./&#39;,
                          orientation=&#39;spr&#39;,
                          merged_data_filename=&#39;merged_data.tif&#39;,
                          debug=False,
                          params=None):
        &#34;&#34;&#34;
        Function to compute the registration to the Atlas. It is just a wrapper to call brainreg.

        Parameters
        ----------
        output_dir: (str) output directory to save atlas
        orientation: (str) orientation of the input data with respect to the origin in Z,Y,X order. E.g. &#39;spr&#39; means
                        superior (so going from origin to z = zlim we go from superior to inferior), posterior
                        (so going from origin to y = ylim we go from posterior to anterior part) and right (so going
                         from origin to x = xlim we go from right to left part)
        merged_data_filename: (str) named of the merged array (Brainreg reads data from files so we need to save
                                the merged volume beforehand.
        params: (dict) dictionary with keys as brainreg options and values as parameters (see here:
                https://docs.brainglobe.info/brainreg/user-guide/parameters)

        Returns
        -------
        None
        &#34;&#34;&#34;

        # Create directories if they do not exist
        atlas_dir = os.path.join(output_dir, &#39;atlas&#39;)
        Path(atlas_dir).mkdir(parents=True, exist_ok=True)

        # If merged_data is a path we ask brainreg to work on this file
        if isinstance(self.merged_data, str):
            path_merged_data = self.merged_data
        # Else it means it&#39;s an array so we have to save it first
        else:
            path_merged_data = os.path.join(output_dir, merged_data_filename)
            imsave(path_merged_data, self.merged_data)

        command = &#39;brainreg {} {} -v {} {} {} --orientation {} --save-original-orientation&#39;.format(&#39;&#34;&#39; + path_merged_data + &#39;&#34;&#39;,
                                                            &#39;&#34;&#39; + atlas_dir + &#39;&#34;&#39;,
                                                            self.pixel_size_data[0]*self.downsample,
                                                            self.pixel_size_data[1]*self.downsample,
                                                            self.pixel_size_data[2]*self.downsample,
                                                            orientation)

        if params is not None:
            for key, value in params.items():
                command += &#39; --{} {}&#39;.format(key, value)

        if debug:
            command += &#39; --debug&#39;

        # Execute brainreg
        os.system(command)

        self.load_atlas(os.path.join(atlas_dir, &#39;registered_atlas.tiff&#39;))

    def get_cells_id(self, cells):
        &#34;&#34;&#34;
        Returns the Allen Brain Atlas region ID for each cell.

        Parameters
        ----------
        cells: (array) cell positions.

        Returns
        -------
        labels: (array) containing the cell region ID.
        &#34;&#34;&#34;
        labels = self.atlas[np.floor(cells.cells[:, 0]/self.z_downsample).astype(&#39;uint64&#39;),
                        np.floor(cells.cells[:, 1]/self.y_downsample).astype(&#39;uint64&#39;),
                        np.floor(cells.cells[:, 2]/self.x_downsample).astype(&#39;uint64&#39;)]

        return labels

    def get_loc_id(self, x, y, z):
        &#34;&#34;&#34;
        Return the ID (brain region) of a given position (typically to retrieve cell position in the brain).

        Parameters
        ----------
        x: (int) x position
        y: (int) y position
        z: (int) z position

        Returns
        -------
        ID at the queried position.
        &#34;&#34;&#34;
        return self.atlas[int(z / self.z_downsample), int(y / self.y_downsample), int(x / self.x_downsample)]

    def get_ontology_mapping(self, labels, n=0):
        &#34;&#34;&#34;
        Get the mapping between area ID and name with Allen SDK.

        Parameters
        ----------
        labels: (array) array of labels to group by ID and fetch area name.
        n: (int) number of parent area to group for.

        Returns
        -------
        area_count: (dict) area names with the counts.
        &#34;&#34;&#34;
        rspc = ReferenceSpaceCache(25, &#39;annotation/ccf_2017&#39;, manifest=&#39;manifest.json&#39;)
        tree = rspc.get_structure_tree(structure_graph_id=1)
        name_map = tree.get_name_map()
        ancestor_map = tree.get_ancestor_id_map()
        area_count = {}
        n_not_found = 0
        area_unknown = {}
        id_count = {}
        for l in labels:
            try:
                ids = ancestor_map[int(l)]
            except KeyError:
                n_not_found += 1
                if &#39;unknown&#39; not in area_count:
                    area_count[&#39;unknown&#39;] = 1
                else:
                    area_count[&#39;unknown&#39;] += 1
                if int(l) not in area_unknown:
                    area_unknown[int(l)] = 1
                else:
                    area_unknown[int(l)] += 1
                continue

            if len(ids) &lt;= 2:
                id = ids[0]
            elif len(ids) &lt;= n:
                id = ids[-2]
            else:
                id = ids[n if n &lt; len(ids) - 1 else n - 1]

            # Get the name and store it
            name = name_map[id]
            if name not in area_count:
                area_count[name] = 1
            else:
                area_count[name] += 1

        # Display summary
        if n == 0:
            if n_not_found &gt; 0:
                print(&#39;\nUnknown ontology ID found for {} objects ({:0.2f}%).&#39;.format(n_not_found,
                                                                                      n_not_found/len(labels)*100))
                print(&#39;Unknown ontology IDs and occurrences:\n&#39;)
                print(area_unknown)
            else:
                print(&#39;\nAll objects were assigned to an atlas ontology category.\n&#39;)

        return pd.DataFrame.from_dict(area_count, orient=&#39;index&#39;)

    def get_cells_number_per_region(self, cells_id):
        &#34;&#34;&#34;
        Retuns the number of cell per region.

        Parameters
        ----------
        cells_id: (array) cells ID (typically computed by self.get_cells_id())

        Returns
        -------
        heatmap: (array) 3D array where each brain region value is the number of cells contained in this region.
        &#34;&#34;&#34;

        # Remove 0s
        cells_id = np.delete(cells_id, cells_id==0)
        id_count = {}
        for id in cells_id:
            if id not in id_count:
                id_count[id] = 1
            else:
                id_count[id] += 1

        heatmap = np.zeros_like(self.atlas)
        for id, counts in id_count.items():
            heatmap[self.atlas==id] = counts

        return heatmap

    def get_cells_density_per_region(self, cells_id):
        &#34;&#34;&#34;
        Retuns the cell density (number of cell per voxel) per region.

        Parameters
        ----------
        cells_id: (array) cells ID (typically computed by self.get_cells_id())

        Returns
        -------
        heatmap: (array) 3D array where each brain region value is the cell density in this region.
        &#34;&#34;&#34;

        # Remove 0s
        cells_id = np.delete(cells_id, cells_id == 0)
        id_count = {}
        for id in cells_id:
            if id not in id_count:
                id_count[id] = 1
            else:
                id_count[id] += 1

        heatmap = np.zeros_like(self.atlas, dtype=&#39;float64&#39;)
        for id, counts in id_count.items():
            tmp = (self.atlas == id)
            heatmap[tmp] = counts/np.sum(tmp)

        return heatmap

    def get_cells_density(self, cells, kernel_size):
        &#34;&#34;&#34;
        Retuns the cell density (local average number of cell per voxel). The local average is computed using a gaussian
        kernel.

        Parameters
        ----------
        cells: (array) cell positions
        kernel_size: (int) radius of the gaussian for local cell density estimation

        Returns
        -------

        &#34;&#34;&#34;

        heatmap = np.zeros((self.atlas.shape)).astype(int)
        for i in tqdm(range(cells.shape[0]), desc=&#39;Building density map..&#39;):
            z = int(cells[i, 0]/self.z_downsample)
            y = int(cells[i, 1]/self.y_downsample)
            x = int(cells[i, 2]/self.x_downsample)
            heatmap[z, y, x] = 1

        return gaussian(heatmap, sigma=kernel_size)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pipapr.atlaser.tileAtlaser.from_atlas"><code class="name flex">
<span>def <span class="ident">from_atlas</span></span>(<span>atlas: (<built-in function array>, <class 'str'>), downsample, original_pixel_size: (<built-in function array>, <class 'list'>))</span>
</code></dt>
<dd>
<div class="desc"><p>Constructor from a previously computed Atlas. Typically to perform postprocessing using an Atlas (e.g.
count cells per brain region).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atlas</code></strong> :&ensp;<code>(np.array, str) atlas data</code> or <code>path for loading the atlas data</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>downsample</code></strong> :&ensp;<code>(int) downsampling used by APRSlicer to reconstruct the lower resolution pixel data used</code></dt>
<dd>for registration to the Atlas.</dd>
<dt><strong><code>original_pixel_size</code></strong> :&ensp;<code>(np.array, list) pixel size in µm on the original data</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_atlas(cls,
              atlas: (np.array, str),
              downsample,
              original_pixel_size: (np.array, list)):
    &#34;&#34;&#34;
    Constructor from a previously computed Atlas. Typically to perform postprocessing using an Atlas (e.g.
    count cells per brain region).

    Parameters
    ----------
    atlas: (np.array, str) atlas data or path for loading the atlas data
    downsample: (int) downsampling used by APRSlicer to reconstruct the lower resolution pixel data used
                        for registration to the Atlas.
    original_pixel_size: (np.array, list) pixel size in µm on the original data

    Returns
    -------

    &#34;&#34;&#34;

    return cls(original_pixel_size=original_pixel_size,
               downsample=downsample,
               atlas=atlas,
               merged_data=None)</code></pre>
</details>
</dd>
<dt id="pipapr.atlaser.tileAtlaser.from_merger"><code class="name flex">
<span>def <span class="ident">from_merger</span></span>(<span>merger: <a title="pipapr.stitcher.tileMerger" href="stitcher.html#pipapr.stitcher.tileMerger">tileMerger</a>, original_pixel_size: (<built-in function array>, <class 'list'>))</span>
</code></dt>
<dd>
<div class="desc"><p>Constructor from a tileMerger object. Typically to perform the registration to the Atlas on
autofluorescence data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>merger</code></strong> :&ensp;<code>(tileMerger) tileMerger object</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>original_pixel_size</code></strong> :&ensp;<code>(np.array, list) pixel size in µm on the original data</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pipapr.atlaser.tileAtlaser" href="#pipapr.atlaser.tileAtlaser">tileAtlaser</a> object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_merger(cls,
               merger: pipapr.stitcher.tileMerger,
               original_pixel_size: (np.array, list)):
    &#34;&#34;&#34;
    Constructor from a tileMerger object. Typically to perform the registration to the Atlas on
    autofluorescence data.

    Parameters
    ----------
    merger: (tileMerger) tileMerger object
    original_pixel_size: (np.array, list) pixel size in µm on the original data

    Returns
    -------
    tileAtlaser object
    &#34;&#34;&#34;

    return cls(original_pixel_size=original_pixel_size,
               downsample=merger.downsample,
               atlas=None,
               merged_data=merger.merged_data)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pipapr.atlaser.tileAtlaser.get_cells_density"><code class="name flex">
<span>def <span class="ident">get_cells_density</span></span>(<span>self, cells, kernel_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Retuns the cell density (local average number of cell per voxel). The local average is computed using a gaussian
kernel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cells</code></strong> :&ensp;<code>(array) cell positions</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>kernel_size</code></strong> :&ensp;<code>(int) radius</code> of <code>the gaussian for local cell density estimation</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cells_density(self, cells, kernel_size):
    &#34;&#34;&#34;
    Retuns the cell density (local average number of cell per voxel). The local average is computed using a gaussian
    kernel.

    Parameters
    ----------
    cells: (array) cell positions
    kernel_size: (int) radius of the gaussian for local cell density estimation

    Returns
    -------

    &#34;&#34;&#34;

    heatmap = np.zeros((self.atlas.shape)).astype(int)
    for i in tqdm(range(cells.shape[0]), desc=&#39;Building density map..&#39;):
        z = int(cells[i, 0]/self.z_downsample)
        y = int(cells[i, 1]/self.y_downsample)
        x = int(cells[i, 2]/self.x_downsample)
        heatmap[z, y, x] = 1

    return gaussian(heatmap, sigma=kernel_size)</code></pre>
</details>
</dd>
<dt id="pipapr.atlaser.tileAtlaser.get_cells_density_per_region"><code class="name flex">
<span>def <span class="ident">get_cells_density_per_region</span></span>(<span>self, cells_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Retuns the cell density (number of cell per voxel) per region.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cells_id</code></strong> :&ensp;<code>(array) cells ID (typically computed by self.get_cells_id())</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>heatmap: (array) 3D array where each brain region value is the cell density in this region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cells_density_per_region(self, cells_id):
    &#34;&#34;&#34;
    Retuns the cell density (number of cell per voxel) per region.

    Parameters
    ----------
    cells_id: (array) cells ID (typically computed by self.get_cells_id())

    Returns
    -------
    heatmap: (array) 3D array where each brain region value is the cell density in this region.
    &#34;&#34;&#34;

    # Remove 0s
    cells_id = np.delete(cells_id, cells_id == 0)
    id_count = {}
    for id in cells_id:
        if id not in id_count:
            id_count[id] = 1
        else:
            id_count[id] += 1

    heatmap = np.zeros_like(self.atlas, dtype=&#39;float64&#39;)
    for id, counts in id_count.items():
        tmp = (self.atlas == id)
        heatmap[tmp] = counts/np.sum(tmp)

    return heatmap</code></pre>
</details>
</dd>
<dt id="pipapr.atlaser.tileAtlaser.get_cells_id"><code class="name flex">
<span>def <span class="ident">get_cells_id</span></span>(<span>self, cells)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Allen Brain Atlas region ID for each cell.</p>
<h2 id="parameters">Parameters</h2>
<p>cells: (array) cell positions.</p>
<h2 id="returns">Returns</h2>
<p>labels: (array) containing the cell region ID.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cells_id(self, cells):
    &#34;&#34;&#34;
    Returns the Allen Brain Atlas region ID for each cell.

    Parameters
    ----------
    cells: (array) cell positions.

    Returns
    -------
    labels: (array) containing the cell region ID.
    &#34;&#34;&#34;
    labels = self.atlas[np.floor(cells.cells[:, 0]/self.z_downsample).astype(&#39;uint64&#39;),
                    np.floor(cells.cells[:, 1]/self.y_downsample).astype(&#39;uint64&#39;),
                    np.floor(cells.cells[:, 2]/self.x_downsample).astype(&#39;uint64&#39;)]

    return labels</code></pre>
</details>
</dd>
<dt id="pipapr.atlaser.tileAtlaser.get_cells_number_per_region"><code class="name flex">
<span>def <span class="ident">get_cells_number_per_region</span></span>(<span>self, cells_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Retuns the number of cell per region.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cells_id</code></strong> :&ensp;<code>(array) cells ID (typically computed by self.get_cells_id())</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>heatmap: (array) 3D array where each brain region value is the number of cells contained in this region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cells_number_per_region(self, cells_id):
    &#34;&#34;&#34;
    Retuns the number of cell per region.

    Parameters
    ----------
    cells_id: (array) cells ID (typically computed by self.get_cells_id())

    Returns
    -------
    heatmap: (array) 3D array where each brain region value is the number of cells contained in this region.
    &#34;&#34;&#34;

    # Remove 0s
    cells_id = np.delete(cells_id, cells_id==0)
    id_count = {}
    for id in cells_id:
        if id not in id_count:
            id_count[id] = 1
        else:
            id_count[id] += 1

    heatmap = np.zeros_like(self.atlas)
    for id, counts in id_count.items():
        heatmap[self.atlas==id] = counts

    return heatmap</code></pre>
</details>
</dd>
<dt id="pipapr.atlaser.tileAtlaser.get_loc_id"><code class="name flex">
<span>def <span class="ident">get_loc_id</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the ID (brain region) of a given position (typically to retrieve cell position in the brain).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>(int) x position</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>(int) y position</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>(int) z position</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ID at the queried position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_loc_id(self, x, y, z):
    &#34;&#34;&#34;
    Return the ID (brain region) of a given position (typically to retrieve cell position in the brain).

    Parameters
    ----------
    x: (int) x position
    y: (int) y position
    z: (int) z position

    Returns
    -------
    ID at the queried position.
    &#34;&#34;&#34;
    return self.atlas[int(z / self.z_downsample), int(y / self.y_downsample), int(x / self.x_downsample)]</code></pre>
</details>
</dd>
<dt id="pipapr.atlaser.tileAtlaser.get_ontology_mapping"><code class="name flex">
<span>def <span class="ident">get_ontology_mapping</span></span>(<span>self, labels, n=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the mapping between area ID and name with Allen SDK.</p>
<h2 id="parameters">Parameters</h2>
<p>labels: (array) array of labels to group by ID and fetch area name.
n: (int) number of parent area to group for.</p>
<h2 id="returns">Returns</h2>
<p>area_count: (dict) area names with the counts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ontology_mapping(self, labels, n=0):
    &#34;&#34;&#34;
    Get the mapping between area ID and name with Allen SDK.

    Parameters
    ----------
    labels: (array) array of labels to group by ID and fetch area name.
    n: (int) number of parent area to group for.

    Returns
    -------
    area_count: (dict) area names with the counts.
    &#34;&#34;&#34;
    rspc = ReferenceSpaceCache(25, &#39;annotation/ccf_2017&#39;, manifest=&#39;manifest.json&#39;)
    tree = rspc.get_structure_tree(structure_graph_id=1)
    name_map = tree.get_name_map()
    ancestor_map = tree.get_ancestor_id_map()
    area_count = {}
    n_not_found = 0
    area_unknown = {}
    id_count = {}
    for l in labels:
        try:
            ids = ancestor_map[int(l)]
        except KeyError:
            n_not_found += 1
            if &#39;unknown&#39; not in area_count:
                area_count[&#39;unknown&#39;] = 1
            else:
                area_count[&#39;unknown&#39;] += 1
            if int(l) not in area_unknown:
                area_unknown[int(l)] = 1
            else:
                area_unknown[int(l)] += 1
            continue

        if len(ids) &lt;= 2:
            id = ids[0]
        elif len(ids) &lt;= n:
            id = ids[-2]
        else:
            id = ids[n if n &lt; len(ids) - 1 else n - 1]

        # Get the name and store it
        name = name_map[id]
        if name not in area_count:
            area_count[name] = 1
        else:
            area_count[name] += 1

    # Display summary
    if n == 0:
        if n_not_found &gt; 0:
            print(&#39;\nUnknown ontology ID found for {} objects ({:0.2f}%).&#39;.format(n_not_found,
                                                                                  n_not_found/len(labels)*100))
            print(&#39;Unknown ontology IDs and occurrences:\n&#39;)
            print(area_unknown)
        else:
            print(&#39;\nAll objects were assigned to an atlas ontology category.\n&#39;)

    return pd.DataFrame.from_dict(area_count, orient=&#39;index&#39;)</code></pre>
</details>
</dd>
<dt id="pipapr.atlaser.tileAtlaser.load_atlas"><code class="name flex">
<span>def <span class="ident">load_atlas</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to load a previously computed atlas.</p>
<h2 id="parameters">Parameters</h2>
<p>path: (str) path to the registered atlas file.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_atlas(self, path):
    &#34;&#34;&#34;
    Function to load a previously computed atlas.

    Parameters
    ----------
    path: (str) path to the registered atlas file.

    Returns
    -------
    None
    &#34;&#34;&#34;

    self.atlas = imread(path)</code></pre>
</details>
</dd>
<dt id="pipapr.atlaser.tileAtlaser.register_to_atlas"><code class="name flex">
<span>def <span class="ident">register_to_atlas</span></span>(<span>self, output_dir='./', orientation='spr', merged_data_filename='merged_data.tif', debug=False, params=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to compute the registration to the Atlas. It is just a wrapper to call brainreg.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>output_dir</code></strong> :&ensp;<code>(str) output directory to save atlas</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>orientation</code></strong> :&ensp;<code>(str) orientation</code> of <code>the input data with respect to the origin in Z,Y,X order. E.g. 'spr' means</code></dt>
<dd>superior (so going from origin to z = zlim we go from superior to inferior), posterior
(so going from origin to y = ylim we go from posterior to anterior part) and right (so going
from origin to x = xlim we go from right to left part)</dd>
<dt><strong><code>merged_data_filename</code></strong> :&ensp;<code>(str) named</code> of <code>the merged array (Brainreg reads data from files so we need to save</code></dt>
<dd>the merged volume beforehand.</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>(dict) dictionary with keys as brainreg options and values as parameters (see here:</code></dt>
<dd><a href="https://docs.brainglobe.info/brainreg/user-guide/parameters">https://docs.brainglobe.info/brainreg/user-guide/parameters</a>)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_to_atlas(self,
                      output_dir=&#39;./&#39;,
                      orientation=&#39;spr&#39;,
                      merged_data_filename=&#39;merged_data.tif&#39;,
                      debug=False,
                      params=None):
    &#34;&#34;&#34;
    Function to compute the registration to the Atlas. It is just a wrapper to call brainreg.

    Parameters
    ----------
    output_dir: (str) output directory to save atlas
    orientation: (str) orientation of the input data with respect to the origin in Z,Y,X order. E.g. &#39;spr&#39; means
                    superior (so going from origin to z = zlim we go from superior to inferior), posterior
                    (so going from origin to y = ylim we go from posterior to anterior part) and right (so going
                     from origin to x = xlim we go from right to left part)
    merged_data_filename: (str) named of the merged array (Brainreg reads data from files so we need to save
                            the merged volume beforehand.
    params: (dict) dictionary with keys as brainreg options and values as parameters (see here:
            https://docs.brainglobe.info/brainreg/user-guide/parameters)

    Returns
    -------
    None
    &#34;&#34;&#34;

    # Create directories if they do not exist
    atlas_dir = os.path.join(output_dir, &#39;atlas&#39;)
    Path(atlas_dir).mkdir(parents=True, exist_ok=True)

    # If merged_data is a path we ask brainreg to work on this file
    if isinstance(self.merged_data, str):
        path_merged_data = self.merged_data
    # Else it means it&#39;s an array so we have to save it first
    else:
        path_merged_data = os.path.join(output_dir, merged_data_filename)
        imsave(path_merged_data, self.merged_data)

    command = &#39;brainreg {} {} -v {} {} {} --orientation {} --save-original-orientation&#39;.format(&#39;&#34;&#39; + path_merged_data + &#39;&#34;&#39;,
                                                        &#39;&#34;&#39; + atlas_dir + &#39;&#34;&#39;,
                                                        self.pixel_size_data[0]*self.downsample,
                                                        self.pixel_size_data[1]*self.downsample,
                                                        self.pixel_size_data[2]*self.downsample,
                                                        orientation)

    if params is not None:
        for key, value in params.items():
            command += &#39; --{} {}&#39;.format(key, value)

    if debug:
        command += &#39; --debug&#39;

    # Execute brainreg
    os.system(command)

    self.load_atlas(os.path.join(atlas_dir, &#39;registered_atlas.tiff&#39;))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pipapr" href="index.html">pipapr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pipapr.atlaser.tileAtlaser" href="#pipapr.atlaser.tileAtlaser">tileAtlaser</a></code></h4>
<ul class="">
<li><code><a title="pipapr.atlaser.tileAtlaser.from_atlas" href="#pipapr.atlaser.tileAtlaser.from_atlas">from_atlas</a></code></li>
<li><code><a title="pipapr.atlaser.tileAtlaser.from_merger" href="#pipapr.atlaser.tileAtlaser.from_merger">from_merger</a></code></li>
<li><code><a title="pipapr.atlaser.tileAtlaser.get_cells_density" href="#pipapr.atlaser.tileAtlaser.get_cells_density">get_cells_density</a></code></li>
<li><code><a title="pipapr.atlaser.tileAtlaser.get_cells_density_per_region" href="#pipapr.atlaser.tileAtlaser.get_cells_density_per_region">get_cells_density_per_region</a></code></li>
<li><code><a title="pipapr.atlaser.tileAtlaser.get_cells_id" href="#pipapr.atlaser.tileAtlaser.get_cells_id">get_cells_id</a></code></li>
<li><code><a title="pipapr.atlaser.tileAtlaser.get_cells_number_per_region" href="#pipapr.atlaser.tileAtlaser.get_cells_number_per_region">get_cells_number_per_region</a></code></li>
<li><code><a title="pipapr.atlaser.tileAtlaser.get_loc_id" href="#pipapr.atlaser.tileAtlaser.get_loc_id">get_loc_id</a></code></li>
<li><code><a title="pipapr.atlaser.tileAtlaser.get_ontology_mapping" href="#pipapr.atlaser.tileAtlaser.get_ontology_mapping">get_ontology_mapping</a></code></li>
<li><code><a title="pipapr.atlaser.tileAtlaser.load_atlas" href="#pipapr.atlaser.tileAtlaser.load_atlas">load_atlas</a></code></li>
<li><code><a title="pipapr.atlaser.tileAtlaser.register_to_atlas" href="#pipapr.atlaser.tileAtlaser.register_to_atlas">register_to_atlas</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>