<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pipapr.parser API documentation</title>
<meta name="description" content="Submodule containing classes and functions relative to Parsing …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pipapr.parser</code></h1>
</header>
<section id="section-intro">
<p>Submodule containing classes and functions relative to Parsing.</p>
<p>The general idea of this submodule is to parse the data to be processed later on. This submodule was developed for
our particular folder layout and was particularly adapted for COLM, mesoSPIM and ClearScope.</p>
<p>There are two general way of parsing the data:
- <strong>multitile</strong> parsing (tileParser class), where each tile has a given position on a 2D grid and can therefore be stitched
- <strong>independant</strong> parsing (baseParser class), where each tile is independent</p>
<p>By using this code you agree to the terms of the software license agreement.</p>
<p>© Copyright 2020 Wyss Center for Bio and Neuro Engineering – All rights reserved</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Submodule containing classes and functions relative to Parsing.

The general idea of this submodule is to parse the data to be processed later on. This submodule was developed for
our particular folder layout and was particularly adapted for COLM, mesoSPIM and ClearScope.

There are two general way of parsing the data:
- **multitile** parsing (tileParser class), where each tile has a given position on a 2D grid and can therefore be stitched
- **independant** parsing (baseParser class), where each tile is independent

By using this code you agree to the terms of the software license agreement.

© Copyright 2020 Wyss Center for Bio and Neuro Engineering – All rights reserved
&#34;&#34;&#34;

from glob import glob
import os
import re
import numpy as np
import pipapr


class baseParser():
    &#34;&#34;&#34;
    Class used to parse several independent tiles (not multitile).

    &#34;&#34;&#34;
    def __init__(self, path, frame_size, ftype, channel=0):
        &#34;&#34;&#34;
        Constructor of the baseParser object.

        Parameters
        ----------
        path: (str) path where to look for the data.
        frame_size: (int) size of each frame (camera resolution).
        ftype: (str) input data type in &#39;apr&#39;, &#39;tiff2D&#39; or &#39;tiff3D&#39;

        &#34;&#34;&#34;
        self.path = path
        self.type = ftype
        self.tiles_list = self._get_tile_list()
        self.n_tiles = len(self.tiles_list)
        self.ncol = None
        self.nrow = None
        self.tiles_pattern, self.tile_pattern_path = None, None
        self.neighbors, self.n_edges = None, None
        self.neighbors_tot = None
        self.path_list = self._get_path_list()
        self.overlap = None
        self.frame_size = frame_size
        self._print_info()
        self.channel = channel

        # Define some folders
        base, _ = os.path.split(self.path)
        self.folder_root = base
        self.folder_max_projs = None

    def _print_info(self):
        &#34;&#34;&#34;
        Display parsing summary in the terminal.

        &#34;&#34;&#34;
        print(&#39;\n**********  PARSING DATA **********&#39;)
        print(&#39;Tiles are of type {}.&#39;.format(self.type))
        print(&#39;{} tiles were detected.&#39;.format(self.n_tiles))
        print(&#39;***********************************\n&#39;)

    def _get_tile_list(self):
        &#34;&#34;&#34;
        Returns a list of tiles as a dictionary

        &#34;&#34;&#34;

        files = self._get_tile_path()
        return self._get_tiles_from_path(files)

    def _get_tile_path(self):
        &#34;&#34;&#34;
        Returns a list containing file paths (for tiff3D and APR) or folder paths (for tiff2).

        &#34;&#34;&#34;

        if self.type == &#39;apr&#39;:
            # If files are apr then their names are &#39;row_col.apr&#39;
            files = glob(os.path.join(self.path, &#39;*.apr&#39;))
        elif self.type == &#39;tiff3D&#39;:
            # If files are 3D tiff then their names are &#39;row_col.tif&#39;
            files = glob(os.path.join(self.path, &#39;*.tif&#39;))
        elif self.type == &#39;tiff2D&#39;:
            # If files are 2D tiff then tiff sequence are in folders with name &#34;row_col&#34;
            # files = [f.path for f in os.scandir(self.path) if f.is_dir()]
            files = glob(os.path.join(self.path, &#39;*/&#39;))
        elif self.type == &#39;raw&#39;:
            files = glob(os.path.join(self.path, &#39;*.raw&#39;))
        else:
            raise TypeError(&#39;Error: file type {} not supported.&#39;.format(self.type))

        return files

    def _get_tiles_from_path(self, files):
        &#34;&#34;&#34;
        Create a list of dictionnary for each tile containing it&#39;s path and coordinate on the grid.
        Coordinates are set to None for the baseParser which only parse independant tiles.

        &#34;&#34;&#34;

        tiles = []
        for f in files:
            tile = {&#39;path&#39;: f,
                    &#39;row&#39;: None,
                    &#39;col&#39;: None,
                    }
            tiles.append(tile)

        return tiles

    def _get_path_list(self):
        &#34;&#34;&#34;
        Returns a list containing the path to each tile.

        &#34;&#34;&#34;
        path_list = []
        for tile in self.tiles_list:
            path_list.append(tile[&#39;path&#39;])
        return path_list

    def __getitem__(self, item):
        &#34;&#34;&#34;
        Return tiles, add neighbors information before returning.

        &#34;&#34;&#34;
        t = self.tiles_list[item]
        path = t[&#39;path&#39;]
        col = t[&#39;col&#39;]
        row = t[&#39;row&#39;]

        return pipapr.loader.tileLoader(path=path,
                                          row=row,
                                          col=col,
                                          ftype=self.type,
                                          neighbors=self.neighbors,
                                          neighbors_tot=self.neighbors_tot,
                                          neighbors_path=None,
                                          frame_size=self.frame_size,
                                          folder_root=self.folder_root,
                                          channel=self.channel)

    def __len__(self):
        &#34;&#34;&#34;
        Returns the number of tiles.

        &#34;&#34;&#34;
        return self.n_tiles


class tileParser(baseParser):
    &#34;&#34;&#34;
    Class used to parse multi-tile data where each tile position in space matters. Tile parsed this way are usually
    stitched later on.

    &#34;&#34;&#34;
    def __init__(self, path, frame_size=2048, ftype=None, nrow=None, ncol=None, channel=0):
        &#34;&#34;&#34;
        Constructor of the tileParser object.

        Parameters
        ----------
        path: (str) path where to look for the data.
        frame_size: (int) size of each frame (camera resolution).
        ftype: (str) input data type in &#39;apr&#39;, &#39;tiff2D&#39; or &#39;tiff3D&#39;
        nrow: (int) number of row for parsing COLM LOCXXX data
        ncol: (int) number of col for parsing COLM LOCXXX data
        channel: (int) fluorescence channel for parsing COLM LOCXXX data

        &#34;&#34;&#34;
        self.path = path
        if ftype is None:
            self.type = self._get_type()
        else:
            self.type = ftype

        if (nrow is not None) and (ncol is not None):
            self.tiles_list = self._get_tile_list_LOC(ncol)
        else:
            self.tiles_list = self._get_tile_list()
        self._correct_offset()
        self.n_tiles = len(self.tiles_list)
        if self.n_tiles == 0:
            raise FileNotFoundError(&#39;Error: no tile were found.&#39;)
        self.ncol = self._get_ncol()
        self.nrow = self._get_nrow()
        self._sort_tiles()
        self.tiles_pattern, self.tile_pattern_path = self._get_tiles_pattern()
        self.neighbors, self.n_edges = self._get_neighbors_map()
        self.neighbors_tot = self._get_total_neighbors_map()
        self.path_list = self._get_path_list()
        self.frame_size = frame_size
        self.channel = channel
        self._print_info()

        # Define some folders
        base, _ = os.path.split(self.path)
        self.folder_root = base
        self.folder_max_projs = os.path.join(base, &#39;max_projs&#39;)

    def _correct_offset(self):
        &#34;&#34;&#34;
        If the row or column do not start at 0, then we subtract the min_row and min_col so that it starts at 0.

        &#34;&#34;&#34;

        col_min = 1000
        row_min = 1000
        for tile in self.tiles_list:
            row_min = min(row_min, tile[&#39;row&#39;])
            col_min = min(col_min, tile[&#39;col&#39;])

        if (row_min &gt; 0) or (col_min &gt; 0):
            for tile in self.tiles_list:
                tile[&#39;row&#39;] -= row_min
                tile[&#39;col&#39;] -= col_min

    def _print_info(self):
        &#34;&#34;&#34;
        Display parsing summary in the terminal.

        &#34;&#34;&#34;
        print(&#39;\n**********  PARSING DATA **********&#39;)
        print(&#39;{}&#39;.format(self.path))
        print(&#39;Tiles are of type {}.&#39;.format(self.type))
        print(&#39;{} tiles were detected.&#39;.format(self.n_tiles))
        print(&#39;{} rows and {} columns.&#39;.format(self.nrow, self.ncol))
        print(&#39;***********************************\n&#39;)

    def _get_type(self):
        &#34;&#34;&#34;
        Automatically determine file type based on what&#39;s inside &#39;path&#39;.

        &#34;&#34;&#34;
        folders = glob(os.path.join(self.path, &#39;*/&#39;))
        files_tif = glob(os.path.join(self.path, &#39;*.tif&#39;))
        files_apr = glob(os.path.join(self.path, &#39;*.apr&#39;))
        detection = (len(folders) != 0) + (len(files_tif) != 0)+(len(files_apr) != 0)

        if detection != 1:
            raise ValueError(&#39;Error: could not determine file type automatically, please pass it to the constructor.&#39;)

        if len(folders) != 0:
            return &#39;tiff2D&#39;
        elif len(files_tif) != 0:
            return &#39;tiff3D&#39;
        elif len(files_apr) != 0:
            return &#39;apr&#39;

    def _get_tiles_from_path(self, files):
        &#34;&#34;&#34;
        Create a list of dictionnary for each tile containing it&#39;s path and coordinate on the grid.

        &#34;&#34;&#34;
        tiles = []
        for f in files:

            pattern_search = re.search(os.path.sep + &#39;(\d+)_(\d+)&#39;, f)
            if pattern_search:
                row = int(pattern_search.group(1))
                col = int(pattern_search.group(2))
            else:
                raise TypeError(&#39;Couldn&#39;&#39;t get the column/row.&#39;)

            tile = {&#39;path&#39;: f,
                    &#39;row&#39;: row,
                    &#39;col&#39;: col,
                    }
            tiles.append(tile)

        return tiles

    def _get_tile_list_LOC(self, ncol):
        &#34;&#34;&#34;
        Returns a list of tiles as a dictionary for data saved as LOC00X.

        &#34;&#34;&#34;

        files = glob(os.path.join(self.path, &#39;*/&#39;))

        tiles = []
        for f in files:

            pattern_search = re.findall(&#39;/LOC(\d+)&#39;, f)
            if pattern_search != []:
                n = int(pattern_search[-1])
                row = n // ncol
                col = n % ncol
            else:
                raise TypeError(&#39;Couldn&#39;&#39;t get the column/row.&#39;)

            tile = {&#39;path&#39;: f,
                    &#39;row&#39;: row,
                    &#39;col&#39;: col,
                    }
            tiles.append(tile)
        return tiles

    def _sort_tiles(self):
        &#34;&#34;&#34;
        Sort tiles so that they are arranged in columns and rows (read from left to right and top to bottom).

        &#34;&#34;&#34;
        tiles_sorted = []
        for v in range(self.nrow):
            for h in range(self.ncol):
                for i, t in enumerate(self.tiles_list):
                    if t[&#39;col&#39;]==h and t[&#39;row&#39;]==v:
                        tiles_sorted.append(t)
                        self.tiles_list.pop(i)
                        break

        self.tiles_list = tiles_sorted

    def _get_ncol(self):
        &#34;&#34;&#34;
        Returns the number of columns (H) to be stitched.

        &#34;&#34;&#34;
        ncol = 0
        for tile in self.tiles_list:
            if tile[&#39;col&#39;] &gt; ncol:
                ncol = tile[&#39;col&#39;]
        return ncol+1

    def _get_nrow(self):
        &#34;&#34;&#34;
        Returns the number of rows (V) to be stitched.

        &#34;&#34;&#34;
        nrow = 0
        for tile in self.tiles_list:
            if tile[&#39;row&#39;] &gt; nrow:
                nrow = tile[&#39;row&#39;]
        return nrow+1

    def _get_tiles_pattern(self):
        &#34;&#34;&#34;
        Return the tile pattern (0 = no tile, 1 = tile)

        &#34;&#34;&#34;
        tiles_pattern = np.zeros((self.nrow, self.ncol))
        tiles_pattern_path = np.empty((self.nrow, self.ncol), dtype=object)
        for tile in self.tiles_list:
            tiles_pattern[tile[&#39;row&#39;], tile[&#39;col&#39;]] = 1
            tiles_pattern_path[tile[&#39;row&#39;], tile[&#39;col&#39;]] = tile[&#39;path&#39;]
        return tiles_pattern, tiles_pattern_path

    def _get_total_neighbors_map(self):
        &#34;&#34;&#34;
        Return the total neighbors maps (with redundancy in the case of undirected graph).

        &#34;&#34;&#34;
        # Initialize neighbors
        neighbors_tot = np.empty((self.nrow, self.ncol), dtype=object)
        cnt = 0
        for x in range(self.ncol):
            for y in range(self.nrow):
                if self.tiles_pattern[y, x] == 0:
                    pass
                # Fill up 2D list
                tmp = []
                if x &lt; self.ncol-1 and self.tiles_pattern[y, x+1] == 1:
                    # EAST
                    tmp.append([y, x+1])
                    cnt += 1
                if y &lt; self.nrow-1 and self.tiles_pattern[y+1, x] == 1:
                    # SOUTH
                    tmp.append([y+1, x])
                    cnt += 1
                if x &gt; 0 and self.tiles_pattern[y, x-1] == 1:
                    # WEST
                    tmp.append([y, x-1])
                    cnt += 1
                if y &gt; 0 and self.tiles_pattern[y-1, x] == 1:
                    # NORTH
                    tmp.append([y-1, x])
                    cnt += 1
                neighbors_tot[y, x] = tmp
        return neighbors_tot

    def _get_neighbors_map(self):
        &#34;&#34;&#34;
        Returns the non-redundant neighbors map: neighbors[row, col] gives a list of neighbors and the total
        number of pair-wise neighbors. Only SOUTH and EAST are returned to avoid the redundancy.

        &#34;&#34;&#34;
        # Initialize neighbors
        neighbors = np.empty((self.nrow, self.ncol), dtype=object)
        cnt = 0
        for x in range(self.ncol):
            for y in range(self.nrow):
                if self.tiles_pattern[y, x] == 0:
                    pass
                # Fill up 2D list
                tmp = []
                if x &lt; self.ncol-1 and self.tiles_pattern[y, x+1] == 1:
                    # EAST
                    tmp.append([y, x+1])
                    cnt += 1
                if y &lt; self.nrow-1 and self.tiles_pattern[y+1, x] == 1:
                    # SOUTH
                    tmp.append([y+1, x])
                    cnt += 1
                neighbors[y, x] = tmp

        return neighbors, cnt

    def __getitem__(self, item):
        &#34;&#34;&#34;
        Return tiles, add neighbors information before returning.

        &#34;&#34;&#34;
        if isinstance(item, tuple):
            if (item[0] &gt; self.nrow) or (item[0] &lt; 0):
                raise ValueError(&#39;Error: tile at requested coordinates does not exists.&#39;)
            if (item[1] &gt; self.ncol) or (item[1] &lt; 0):
                raise ValueError(&#39;Error: tile at requested coordinates does not exists.&#39;)
            t = self.tiles_list[item[0]*self.ncol + item[1]]
        else:
            t = self.tiles_list[item]

        path = t[&#39;path&#39;]
        col = t[&#39;col&#39;]
        row = t[&#39;row&#39;]
        neighbors = self.neighbors[row, col]
        neighbors_tot = self.neighbors_tot[row, col]

        neighbors_path = []
        for r, c in neighbors:
            if self.tiles_pattern[r, c]:
                neighbors_path.append(self.tile_pattern_path[r, c])

        return pipapr.loader.tileLoader(path=path,
                                          row=row,
                                          col=col,
                                          ftype=self.type,
                                          neighbors=neighbors,
                                          neighbors_tot=neighbors_tot,
                                          neighbors_path=neighbors_path,
                                          frame_size=self.frame_size,
                                          folder_root=self.folder_root,
                                          channel=self.channel)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pipapr.parser.baseParser"><code class="flex name class">
<span>class <span class="ident">baseParser</span></span>
<span>(</span><span>path, frame_size, ftype, channel=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to parse several independent tiles (not multitile).</p>
<p>Constructor of the baseParser object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>path: (str) path where to look for the data.</dt>
<dt>frame_size: (int) size of each frame (camera resolution).</dt>
<dt><strong><code>ftype</code></strong> :&ensp;<code>(str) input data type in 'apr', 'tiff2D'</code> or <code>'tiff3D'</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class baseParser():
    &#34;&#34;&#34;
    Class used to parse several independent tiles (not multitile).

    &#34;&#34;&#34;
    def __init__(self, path, frame_size, ftype, channel=0):
        &#34;&#34;&#34;
        Constructor of the baseParser object.

        Parameters
        ----------
        path: (str) path where to look for the data.
        frame_size: (int) size of each frame (camera resolution).
        ftype: (str) input data type in &#39;apr&#39;, &#39;tiff2D&#39; or &#39;tiff3D&#39;

        &#34;&#34;&#34;
        self.path = path
        self.type = ftype
        self.tiles_list = self._get_tile_list()
        self.n_tiles = len(self.tiles_list)
        self.ncol = None
        self.nrow = None
        self.tiles_pattern, self.tile_pattern_path = None, None
        self.neighbors, self.n_edges = None, None
        self.neighbors_tot = None
        self.path_list = self._get_path_list()
        self.overlap = None
        self.frame_size = frame_size
        self._print_info()
        self.channel = channel

        # Define some folders
        base, _ = os.path.split(self.path)
        self.folder_root = base
        self.folder_max_projs = None

    def _print_info(self):
        &#34;&#34;&#34;
        Display parsing summary in the terminal.

        &#34;&#34;&#34;
        print(&#39;\n**********  PARSING DATA **********&#39;)
        print(&#39;Tiles are of type {}.&#39;.format(self.type))
        print(&#39;{} tiles were detected.&#39;.format(self.n_tiles))
        print(&#39;***********************************\n&#39;)

    def _get_tile_list(self):
        &#34;&#34;&#34;
        Returns a list of tiles as a dictionary

        &#34;&#34;&#34;

        files = self._get_tile_path()
        return self._get_tiles_from_path(files)

    def _get_tile_path(self):
        &#34;&#34;&#34;
        Returns a list containing file paths (for tiff3D and APR) or folder paths (for tiff2).

        &#34;&#34;&#34;

        if self.type == &#39;apr&#39;:
            # If files are apr then their names are &#39;row_col.apr&#39;
            files = glob(os.path.join(self.path, &#39;*.apr&#39;))
        elif self.type == &#39;tiff3D&#39;:
            # If files are 3D tiff then their names are &#39;row_col.tif&#39;
            files = glob(os.path.join(self.path, &#39;*.tif&#39;))
        elif self.type == &#39;tiff2D&#39;:
            # If files are 2D tiff then tiff sequence are in folders with name &#34;row_col&#34;
            # files = [f.path for f in os.scandir(self.path) if f.is_dir()]
            files = glob(os.path.join(self.path, &#39;*/&#39;))
        elif self.type == &#39;raw&#39;:
            files = glob(os.path.join(self.path, &#39;*.raw&#39;))
        else:
            raise TypeError(&#39;Error: file type {} not supported.&#39;.format(self.type))

        return files

    def _get_tiles_from_path(self, files):
        &#34;&#34;&#34;
        Create a list of dictionnary for each tile containing it&#39;s path and coordinate on the grid.
        Coordinates are set to None for the baseParser which only parse independant tiles.

        &#34;&#34;&#34;

        tiles = []
        for f in files:
            tile = {&#39;path&#39;: f,
                    &#39;row&#39;: None,
                    &#39;col&#39;: None,
                    }
            tiles.append(tile)

        return tiles

    def _get_path_list(self):
        &#34;&#34;&#34;
        Returns a list containing the path to each tile.

        &#34;&#34;&#34;
        path_list = []
        for tile in self.tiles_list:
            path_list.append(tile[&#39;path&#39;])
        return path_list

    def __getitem__(self, item):
        &#34;&#34;&#34;
        Return tiles, add neighbors information before returning.

        &#34;&#34;&#34;
        t = self.tiles_list[item]
        path = t[&#39;path&#39;]
        col = t[&#39;col&#39;]
        row = t[&#39;row&#39;]

        return pipapr.loader.tileLoader(path=path,
                                          row=row,
                                          col=col,
                                          ftype=self.type,
                                          neighbors=self.neighbors,
                                          neighbors_tot=self.neighbors_tot,
                                          neighbors_path=None,
                                          frame_size=self.frame_size,
                                          folder_root=self.folder_root,
                                          channel=self.channel)

    def __len__(self):
        &#34;&#34;&#34;
        Returns the number of tiles.

        &#34;&#34;&#34;
        return self.n_tiles</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pipapr.parser.tileParser" href="#pipapr.parser.tileParser">tileParser</a></li>
</ul>
</dd>
<dt id="pipapr.parser.tileParser"><code class="flex name class">
<span>class <span class="ident">tileParser</span></span>
<span>(</span><span>path, frame_size=2048, ftype=None, nrow=None, ncol=None, channel=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to parse multi-tile data where each tile position in space matters. Tile parsed this way are usually
stitched later on.</p>
<p>Constructor of the tileParser object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>path: (str) path where to look for the data.</dt>
<dt>frame_size: (int) size of each frame (camera resolution).</dt>
<dt><strong><code>ftype</code></strong> :&ensp;<code>(str) input data type in 'apr', 'tiff2D'</code> or <code>'tiff3D'</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>nrow</code></strong> :&ensp;<code>(int) number</code> of <code>row for parsing COLM LOCXXX data</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ncol</code></strong> :&ensp;<code>(int) number</code> of <code>col for parsing COLM LOCXXX data</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>(int) fluorescence channel for parsing COLM LOCXXX data</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class tileParser(baseParser):
    &#34;&#34;&#34;
    Class used to parse multi-tile data where each tile position in space matters. Tile parsed this way are usually
    stitched later on.

    &#34;&#34;&#34;
    def __init__(self, path, frame_size=2048, ftype=None, nrow=None, ncol=None, channel=0):
        &#34;&#34;&#34;
        Constructor of the tileParser object.

        Parameters
        ----------
        path: (str) path where to look for the data.
        frame_size: (int) size of each frame (camera resolution).
        ftype: (str) input data type in &#39;apr&#39;, &#39;tiff2D&#39; or &#39;tiff3D&#39;
        nrow: (int) number of row for parsing COLM LOCXXX data
        ncol: (int) number of col for parsing COLM LOCXXX data
        channel: (int) fluorescence channel for parsing COLM LOCXXX data

        &#34;&#34;&#34;
        self.path = path
        if ftype is None:
            self.type = self._get_type()
        else:
            self.type = ftype

        if (nrow is not None) and (ncol is not None):
            self.tiles_list = self._get_tile_list_LOC(ncol)
        else:
            self.tiles_list = self._get_tile_list()
        self._correct_offset()
        self.n_tiles = len(self.tiles_list)
        if self.n_tiles == 0:
            raise FileNotFoundError(&#39;Error: no tile were found.&#39;)
        self.ncol = self._get_ncol()
        self.nrow = self._get_nrow()
        self._sort_tiles()
        self.tiles_pattern, self.tile_pattern_path = self._get_tiles_pattern()
        self.neighbors, self.n_edges = self._get_neighbors_map()
        self.neighbors_tot = self._get_total_neighbors_map()
        self.path_list = self._get_path_list()
        self.frame_size = frame_size
        self.channel = channel
        self._print_info()

        # Define some folders
        base, _ = os.path.split(self.path)
        self.folder_root = base
        self.folder_max_projs = os.path.join(base, &#39;max_projs&#39;)

    def _correct_offset(self):
        &#34;&#34;&#34;
        If the row or column do not start at 0, then we subtract the min_row and min_col so that it starts at 0.

        &#34;&#34;&#34;

        col_min = 1000
        row_min = 1000
        for tile in self.tiles_list:
            row_min = min(row_min, tile[&#39;row&#39;])
            col_min = min(col_min, tile[&#39;col&#39;])

        if (row_min &gt; 0) or (col_min &gt; 0):
            for tile in self.tiles_list:
                tile[&#39;row&#39;] -= row_min
                tile[&#39;col&#39;] -= col_min

    def _print_info(self):
        &#34;&#34;&#34;
        Display parsing summary in the terminal.

        &#34;&#34;&#34;
        print(&#39;\n**********  PARSING DATA **********&#39;)
        print(&#39;{}&#39;.format(self.path))
        print(&#39;Tiles are of type {}.&#39;.format(self.type))
        print(&#39;{} tiles were detected.&#39;.format(self.n_tiles))
        print(&#39;{} rows and {} columns.&#39;.format(self.nrow, self.ncol))
        print(&#39;***********************************\n&#39;)

    def _get_type(self):
        &#34;&#34;&#34;
        Automatically determine file type based on what&#39;s inside &#39;path&#39;.

        &#34;&#34;&#34;
        folders = glob(os.path.join(self.path, &#39;*/&#39;))
        files_tif = glob(os.path.join(self.path, &#39;*.tif&#39;))
        files_apr = glob(os.path.join(self.path, &#39;*.apr&#39;))
        detection = (len(folders) != 0) + (len(files_tif) != 0)+(len(files_apr) != 0)

        if detection != 1:
            raise ValueError(&#39;Error: could not determine file type automatically, please pass it to the constructor.&#39;)

        if len(folders) != 0:
            return &#39;tiff2D&#39;
        elif len(files_tif) != 0:
            return &#39;tiff3D&#39;
        elif len(files_apr) != 0:
            return &#39;apr&#39;

    def _get_tiles_from_path(self, files):
        &#34;&#34;&#34;
        Create a list of dictionnary for each tile containing it&#39;s path and coordinate on the grid.

        &#34;&#34;&#34;
        tiles = []
        for f in files:

            pattern_search = re.search(os.path.sep + &#39;(\d+)_(\d+)&#39;, f)
            if pattern_search:
                row = int(pattern_search.group(1))
                col = int(pattern_search.group(2))
            else:
                raise TypeError(&#39;Couldn&#39;&#39;t get the column/row.&#39;)

            tile = {&#39;path&#39;: f,
                    &#39;row&#39;: row,
                    &#39;col&#39;: col,
                    }
            tiles.append(tile)

        return tiles

    def _get_tile_list_LOC(self, ncol):
        &#34;&#34;&#34;
        Returns a list of tiles as a dictionary for data saved as LOC00X.

        &#34;&#34;&#34;

        files = glob(os.path.join(self.path, &#39;*/&#39;))

        tiles = []
        for f in files:

            pattern_search = re.findall(&#39;/LOC(\d+)&#39;, f)
            if pattern_search != []:
                n = int(pattern_search[-1])
                row = n // ncol
                col = n % ncol
            else:
                raise TypeError(&#39;Couldn&#39;&#39;t get the column/row.&#39;)

            tile = {&#39;path&#39;: f,
                    &#39;row&#39;: row,
                    &#39;col&#39;: col,
                    }
            tiles.append(tile)
        return tiles

    def _sort_tiles(self):
        &#34;&#34;&#34;
        Sort tiles so that they are arranged in columns and rows (read from left to right and top to bottom).

        &#34;&#34;&#34;
        tiles_sorted = []
        for v in range(self.nrow):
            for h in range(self.ncol):
                for i, t in enumerate(self.tiles_list):
                    if t[&#39;col&#39;]==h and t[&#39;row&#39;]==v:
                        tiles_sorted.append(t)
                        self.tiles_list.pop(i)
                        break

        self.tiles_list = tiles_sorted

    def _get_ncol(self):
        &#34;&#34;&#34;
        Returns the number of columns (H) to be stitched.

        &#34;&#34;&#34;
        ncol = 0
        for tile in self.tiles_list:
            if tile[&#39;col&#39;] &gt; ncol:
                ncol = tile[&#39;col&#39;]
        return ncol+1

    def _get_nrow(self):
        &#34;&#34;&#34;
        Returns the number of rows (V) to be stitched.

        &#34;&#34;&#34;
        nrow = 0
        for tile in self.tiles_list:
            if tile[&#39;row&#39;] &gt; nrow:
                nrow = tile[&#39;row&#39;]
        return nrow+1

    def _get_tiles_pattern(self):
        &#34;&#34;&#34;
        Return the tile pattern (0 = no tile, 1 = tile)

        &#34;&#34;&#34;
        tiles_pattern = np.zeros((self.nrow, self.ncol))
        tiles_pattern_path = np.empty((self.nrow, self.ncol), dtype=object)
        for tile in self.tiles_list:
            tiles_pattern[tile[&#39;row&#39;], tile[&#39;col&#39;]] = 1
            tiles_pattern_path[tile[&#39;row&#39;], tile[&#39;col&#39;]] = tile[&#39;path&#39;]
        return tiles_pattern, tiles_pattern_path

    def _get_total_neighbors_map(self):
        &#34;&#34;&#34;
        Return the total neighbors maps (with redundancy in the case of undirected graph).

        &#34;&#34;&#34;
        # Initialize neighbors
        neighbors_tot = np.empty((self.nrow, self.ncol), dtype=object)
        cnt = 0
        for x in range(self.ncol):
            for y in range(self.nrow):
                if self.tiles_pattern[y, x] == 0:
                    pass
                # Fill up 2D list
                tmp = []
                if x &lt; self.ncol-1 and self.tiles_pattern[y, x+1] == 1:
                    # EAST
                    tmp.append([y, x+1])
                    cnt += 1
                if y &lt; self.nrow-1 and self.tiles_pattern[y+1, x] == 1:
                    # SOUTH
                    tmp.append([y+1, x])
                    cnt += 1
                if x &gt; 0 and self.tiles_pattern[y, x-1] == 1:
                    # WEST
                    tmp.append([y, x-1])
                    cnt += 1
                if y &gt; 0 and self.tiles_pattern[y-1, x] == 1:
                    # NORTH
                    tmp.append([y-1, x])
                    cnt += 1
                neighbors_tot[y, x] = tmp
        return neighbors_tot

    def _get_neighbors_map(self):
        &#34;&#34;&#34;
        Returns the non-redundant neighbors map: neighbors[row, col] gives a list of neighbors and the total
        number of pair-wise neighbors. Only SOUTH and EAST are returned to avoid the redundancy.

        &#34;&#34;&#34;
        # Initialize neighbors
        neighbors = np.empty((self.nrow, self.ncol), dtype=object)
        cnt = 0
        for x in range(self.ncol):
            for y in range(self.nrow):
                if self.tiles_pattern[y, x] == 0:
                    pass
                # Fill up 2D list
                tmp = []
                if x &lt; self.ncol-1 and self.tiles_pattern[y, x+1] == 1:
                    # EAST
                    tmp.append([y, x+1])
                    cnt += 1
                if y &lt; self.nrow-1 and self.tiles_pattern[y+1, x] == 1:
                    # SOUTH
                    tmp.append([y+1, x])
                    cnt += 1
                neighbors[y, x] = tmp

        return neighbors, cnt

    def __getitem__(self, item):
        &#34;&#34;&#34;
        Return tiles, add neighbors information before returning.

        &#34;&#34;&#34;
        if isinstance(item, tuple):
            if (item[0] &gt; self.nrow) or (item[0] &lt; 0):
                raise ValueError(&#39;Error: tile at requested coordinates does not exists.&#39;)
            if (item[1] &gt; self.ncol) or (item[1] &lt; 0):
                raise ValueError(&#39;Error: tile at requested coordinates does not exists.&#39;)
            t = self.tiles_list[item[0]*self.ncol + item[1]]
        else:
            t = self.tiles_list[item]

        path = t[&#39;path&#39;]
        col = t[&#39;col&#39;]
        row = t[&#39;row&#39;]
        neighbors = self.neighbors[row, col]
        neighbors_tot = self.neighbors_tot[row, col]

        neighbors_path = []
        for r, c in neighbors:
            if self.tiles_pattern[r, c]:
                neighbors_path.append(self.tile_pattern_path[r, c])

        return pipapr.loader.tileLoader(path=path,
                                          row=row,
                                          col=col,
                                          ftype=self.type,
                                          neighbors=neighbors,
                                          neighbors_tot=neighbors_tot,
                                          neighbors_path=neighbors_path,
                                          frame_size=self.frame_size,
                                          folder_root=self.folder_root,
                                          channel=self.channel)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pipapr.parser.baseParser" href="#pipapr.parser.baseParser">baseParser</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pipapr" href="index.html">pipapr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pipapr.parser.baseParser" href="#pipapr.parser.baseParser">baseParser</a></code></h4>
</li>
<li>
<h4><code><a title="pipapr.parser.tileParser" href="#pipapr.parser.tileParser">tileParser</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>